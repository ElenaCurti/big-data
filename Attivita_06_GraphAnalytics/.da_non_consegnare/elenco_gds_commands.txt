├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.delta.mutate"                           │"The Delta Stepping shortest path algorithm computes the shortest (wei│"gds.allShortestPaths.delta.mutate(graphName :: STRING?, configuration│
│                                                              │ghted) path between one node and any other node in the graph. The comp│ = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: I│
│                                                              │utation is run multi-threaded"                                        │NTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTE│
│                                                              │                                                                      │GER?, computeMillis :: INTEGER?, configuration :: MAP?)"              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.delta.mutate.estimate"                  │"Returns an estimation of the memory consumption for that procedure." │"gds.allShortestPaths.delta.mutate.estimate(graphNameOrConfiguration :│
│                                                              │                                                                      │: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, tree│
│                                                              │                                                                      │View :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: IN│
│                                                              │                                                                      │TEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPerc│
│                                                              │                                                                      │entageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.delta.stats"                            │"The Delta Stepping shortest path algorithm computes the shortest (wei│"gds.allShortestPaths.delta.stats(graphName :: STRING?, configuration │
│                                                              │ghted) path between one node and any other node in the graph. The comp│= {} :: MAP?) :: (postProcessingMillis :: INTEGER?, preProcessingMilli│
│                                                              │utation is run multi-threaded"                                        │s :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.delta.stats.estimate"                   │"Returns an estimation of the memory consumption for that procedure." │"gds.allShortestPaths.delta.stats.estimate(graphNameOrConfiguration ::│
│                                                              │                                                                      │ ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeV│
│                                                              │                                                                      │iew :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INT│
│                                                              │                                                                      │EGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPerce│
│                                                              │                                                                      │ntageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.delta.stream"                           │"The Delta Stepping shortest path algorithm computes the shortest (wei│"gds.allShortestPaths.delta.stream(graphName :: STRING?, configuration│
│                                                              │ghted) path between one node and any other node in the graph. The comp│ = {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNo│
│                                                              │utation is run multi-threaded"                                        │de :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, cos│
│                                                              │                                                                      │ts :: LIST? OF FLOAT?, path :: PATH?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.delta.stream.estimate"                  │"Returns an estimation of the memory consumption for that procedure." │"gds.allShortestPaths.delta.stream.estimate(graphNameOrConfiguration :│
│                                                              │                                                                      │: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, tree│
│                                                              │                                                                      │View :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: IN│
│                                                              │                                                                      │TEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPerc│
│                                                              │                                                                      │entageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.delta.write"                            │"The Delta Stepping shortest path algorithm computes the shortest (wei│"gds.allShortestPaths.delta.write(graphName :: STRING?, configuration │
│                                                              │ghted) path between one node and any other node in the graph. The comp│= {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INT│
│                                                              │utation is run multi-threaded"                                        │EGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGE│
│                                                              │                                                                      │R?, computeMillis :: INTEGER?, configuration :: MAP?)"                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.delta.write.estimate"                   │"Returns an estimation of the memory consumption for that procedure." │"gds.allShortestPaths.delta.write.estimate(graphNameOrConfiguration ::│
│                                                              │                                                                      │ ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeV│
│                                                              │                                                                      │iew :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INT│
│                                                              │                                                                      │EGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPerce│
│                                                              │                                                                      │ntageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.dijkstra.mutate"                        │"The Dijkstra shortest path algorithm computes the shortest (weighted)│"gds.allShortestPaths.dijkstra.mutate(graphName :: STRING?, configurat│
│                                                              │ path between one node and any other node in the graph."              │ion = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :│
│                                                              │                                                                      │: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: I│
│                                                              │                                                                      │NTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.dijkstra.mutate.estimate"               │"Returns an estimation of the memory consumption for that procedure." │"gds.allShortestPaths.dijkstra.mutate.estimate(graphNameOrConfiguratio│
│                                                              │                                                                      │n :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, t│
│                                                              │                                                                      │reeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax ::│
│                                                              │                                                                      │ INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapP│
│                                                              │                                                                      │ercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.dijkstra.stream"                        │"The Dijkstra shortest path algorithm computes the shortest (weighted)│"gds.allShortestPaths.dijkstra.stream(graphName :: STRING?, configurat│
│                                                              │ path between one node and any other node in the graph."              │ion = {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targe│
│                                                              │                                                                      │tNode :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, │
│                                                              │                                                                      │costs :: LIST? OF FLOAT?, path :: PATH?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.dijkstra.stream.estimate"               │"Returns an estimation of the memory consumption for that procedure." │"gds.allShortestPaths.dijkstra.stream.estimate(graphNameOrConfiguratio│
│                                                              │                                                                      │n :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, t│
│                                                              │                                                                      │reeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax ::│
│                                                              │                                                                      │ INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapP│
│                                                              │                                                                      │ercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.dijkstra.write"                         │"The Dijkstra shortest path algorithm computes the shortest (weighted)│"gds.allShortestPaths.dijkstra.write(graphName :: STRING?, configurati│
│                                                              │ path between one node and any other node in the graph."              │on = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: │
│                                                              │                                                                      │INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INT│
│                                                              │                                                                      │EGER?, computeMillis :: INTEGER?, configuration :: MAP?)"             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.allShortestPaths.dijkstra.write.estimate"                │"Returns an estimation of the memory consumption for that procedure." │"gds.allShortestPaths.dijkstra.write.estimate(graphNameOrConfiguration│
│                                                              │                                                                      │ :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, tr│
│                                                              │                                                                      │eeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: │
│                                                              │                                                                      │INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPe│
│                                                              │                                                                      │rcentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.allShortestPaths.stream"                           │"The All Pairs Shortest Path (APSP) calculates the shortest (weighted)│"gds.alpha.allShortestPaths.stream(graphName :: STRING?, configuration│
│                                                              │ path between all pairs of nodes."                                    │ = {} :: MAP?) :: (sourceNodeId :: INTEGER?, targetNodeId :: INTEGER?,│
│                                                              │                                                                      │ distance :: FLOAT?)"                                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.backup"                                            │"The back-up procedure persists graphs and models to disk"            │"gds.alpha.backup(configuration = {} :: MAP?) :: (graphName :: STRING?│
│                                                              │                                                                      │, modelName :: STRING?, backupTime :: DATETIME?, exportPath :: STRING?│
│                                                              │                                                                      │, exportMillis :: INTEGER?, status :: STRING?)"                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.closeness.harmonic.stream"                         │"Harmonic centrality is a way of detecting nodes that are able to spre│"gds.alpha.closeness.harmonic.stream(graphName :: STRING?, configurati│
│                                                              │ad information very efficiently through a graph."                     │on = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.closeness.harmonic.write"                          │"Harmonic centrality is a way of detecting nodes that are able to spre│"gds.alpha.closeness.harmonic.write(graphName :: STRING?, configuratio│
│                                                              │ad information very efficiently through a graph."                     │n = {} :: MAP?) :: (nodes :: INTEGER?, preProcessingMillis :: INTEGER?│
│                                                              │                                                                      │, computeMillis :: INTEGER?, writeMillis :: INTEGER?, writeProperty ::│
│                                                              │                                                                      │ STRING?, centralityDistribution :: MAP?)"                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.conductance.stream"                                │"Evaluates a division of nodes into communities based on the proportio│"gds.alpha.conductance.stream(graphName :: STRING?, configuration = {}│
│                                                              │n of relationships that cross community boundaries."                  │ :: MAP?) :: (community :: INTEGER?, conductance :: FLOAT?)"          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.config.defaults.list"                              │"List defaults; global by default, but also optionally for a specific │"gds.alpha.config.defaults.list(parameters = {} :: MAP?) :: (key :: ST│
│                                                              │user and/ or key"                                                     │RING?, value :: ANY?)"                                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.config.defaults.set"                               │"Set a default; global by, default, but also optionally for a specific│"gds.alpha.config.defaults.set(key :: STRING?, value :: ANY?, username│
│                                                              │ user"                                                                │ = d81eb72e-c499-4f78-90c7-0c76123606a2 :: STRING?) :: VOID"          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.config.limits.list"                                │"List limits; global by default, but also optionally for a specific us│"gds.alpha.config.limits.list(parameters = {} :: MAP?) :: (key :: STRI│
│                                                              │er and/ or key"                                                       │NG?, value :: ANY?)"                                                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.config.limits.set"                                 │"Set a limit; global by, default, but also optionally for a specific u│"gds.alpha.config.limits.set(key :: STRING?, value :: ANY?, username =│
│                                                              │ser"                                                                  │ d81eb72e-c499-4f78-90c7-0c76123606a2 :: STRING?) :: VOID"            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.create.cypherdb"                                   │"Creates a database from a GDS graph."                                │"gds.alpha.create.cypherdb(dbName :: STRING?, graphName :: STRING?) ::│
│                                                              │                                                                      │ (dbName :: STRING?, graphName :: STRING?, createMillis :: INTEGER?)" │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.graph.graphProperty.drop"                          │"Removes a graph property from a projected graph."                    │"gds.alpha.graph.graphProperty.drop(graphName :: STRING?, graphPropert│
│                                                              │                                                                      │y :: STRING?, configuration = {} :: MAP?) :: (graphName :: STRING?, gr│
│                                                              │                                                                      │aphProperty :: STRING?, propertiesRemoved :: INTEGER?)"               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.graph.graphProperty.stream"                        │"Streams the given graph property."                                   │"gds.alpha.graph.graphProperty.stream(graphName :: STRING?, graphPrope│
│                                                              │                                                                      │rty :: STRING?, configuration = {} :: MAP?) :: (propertyValue :: ANY?)│
│                                                              │                                                                      │"                                                                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.graph.sample.rwr"                                  │"Constructs a random subgraph based on random walks with restarts"    │"gds.alpha.graph.sample.rwr(graphName :: STRING?, fromGraphName :: STR│
│                                                              │                                                                      │ING?, configuration = {} :: MAP?) :: (fromGraphName :: STRING?, startN│
│                                                              │                                                                      │odeCount :: INTEGER?, graphName :: STRING?, nodeCount :: INTEGER?, rel│
│                                                              │                                                                      │ationshipCount :: INTEGER?, projectMillis :: INTEGER?)"               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.hits.mutate"                                       │"Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm th│"gds.alpha.hits.mutate(graphName :: STRING?, configuration = {} :: MAP│
│                                                              │at rates nodes"                                                       │?) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, d│
│                                                              │                                                                      │idConverge :: BOOLEAN?, mutateMillis :: INTEGER?, postProcessingMillis│
│                                                              │                                                                      │ :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGE│
│                                                              │                                                                      │R?, configuration :: MAP?)"                                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.hits.mutate.estimate"                              │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.hits.mutate.estimate(graphNameOrConfiguration :: ANY?, algo│
│                                                              │                                                                      │Configuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRI│
│                                                              │                                                                      │NG?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin ::│
│                                                              │                                                                      │ FLOAT?, heapPercentageMax :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.hits.stats"                                        │"Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm th│"gds.alpha.hits.stats(graphName :: STRING?, configuration = {} :: MAP?│
│                                                              │at rates nodes"                                                       │) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, postProcessi│
│                                                              │                                                                      │ngMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :│
│                                                              │                                                                      │: INTEGER?, configuration :: MAP?)"                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.hits.stats.estimate"                               │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.hits.stats.estimate(graphNameOrConfiguration :: ANY?, algoC│
│                                                              │                                                                      │onfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRIN│
│                                                              │                                                                      │G?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeC│
│                                                              │                                                                      │ount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: │
│                                                              │                                                                      │FLOAT?, heapPercentageMax :: FLOAT?)"                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.hits.stream"                                       │"Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm th│"gds.alpha.hits.stream(graphName :: STRING?, configuration = {} :: MAP│
│                                                              │at rates nodes"                                                       │?) :: (nodeId :: INTEGER?, values :: MAP?)"                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.hits.stream.estimate"                              │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.hits.stream.estimate(graphNameOrConfiguration :: ANY?, algo│
│                                                              │                                                                      │Configuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRI│
│                                                              │                                                                      │NG?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin ::│
│                                                              │                                                                      │ FLOAT?, heapPercentageMax :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.hits.write"                                        │"Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm th│"gds.alpha.hits.write(graphName :: STRING?, configuration = {} :: MAP?│
│                                                              │at rates nodes"                                                       │) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, di│
│                                                              │                                                                      │dConverge :: BOOLEAN?, writeMillis :: INTEGER?, postProcessingMillis :│
│                                                              │                                                                      │: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?│
│                                                              │                                                                      │, configuration :: MAP?)"                                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.hits.write.estimate"                               │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.hits.write.estimate(graphNameOrConfiguration :: ANY?, algoC│
│                                                              │                                                                      │onfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRIN│
│                                                              │                                                                      │G?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeC│
│                                                              │                                                                      │ount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: │
│                                                              │                                                                      │FLOAT?, heapPercentageMax :: FLOAT?)"                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.influenceMaximization.greedy.stream"               │"The Greedy algorithm aims to find k nodes that maximize the expected │"gds.alpha.influenceMaximization.greedy.stream(graphName :: STRING?, c│
│                                                              │spread of influence in the network."                                  │onfiguration = {} :: MAP?) :: (nodeId :: INTEGER?, spread :: FLOAT?)" │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.kmeans.mutate"                                     │"The Kmeans  algorithm clusters nodes into different communities based│"gds.alpha.kmeans.mutate(graphName :: STRING?, configuration = {} :: M│
│                                                              │ on Euclidean distance"                                               │AP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, │
│                                                              │                                                                      │communityDistribution :: MAP?, centroids :: LIST? OF LIST? OF FLOAT?, │
│                                                              │                                                                      │averageDistanceToCentroid :: FLOAT?, averageSilhouette :: FLOAT?, post│
│                                                              │                                                                      │ProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, compute│
│                                                              │                                                                      │Millis :: INTEGER?, configuration :: MAP?)"                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.kmeans.mutate.estimate"                            │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.kmeans.mutate.estimate(graphNameOrConfiguration :: ANY?, al│
│                                                              │                                                                      │goConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: ST│
│                                                              │                                                                      │RING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, no│
│                                                              │                                                                      │deCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin │
│                                                              │                                                                      │:: FLOAT?, heapPercentageMax :: FLOAT?)"                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.kmeans.stats"                                      │"Executes the algorithm and returns result statistics without writing │"gds.alpha.kmeans.stats(graphName :: STRING?, configuration = {} :: MA│
│                                                              │the result to Neo4j."                                                 │P?) :: (communityDistribution :: MAP?, centroids :: LIST? OF LIST? OF │
│                                                              │                                                                      │FLOAT?, averageDistanceToCentroid :: FLOAT?, averageSilhouette :: FLOA│
│                                                              │                                                                      │T?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?,│
│                                                              │                                                                      │ computeMillis :: INTEGER?, configuration :: MAP?)"                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.kmeans.stats.estimate"                             │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.kmeans.stats.estimate(graphNameOrConfiguration :: ANY?, alg│
│                                                              │                                                                      │oConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STR│
│                                                              │                                                                      │ING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :│
│                                                              │                                                                      │: FLOAT?, heapPercentageMax :: FLOAT?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.kmeans.stream"                                     │"The Kmeans  algorithm clusters nodes into different communities based│"gds.alpha.kmeans.stream(graphName :: STRING?, configuration = {} :: M│
│                                                              │ on Euclidean distance"                                               │AP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?, distanceFromCent│
│                                                              │                                                                      │roid :: FLOAT?, silhouette :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.kmeans.stream.estimate"                            │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.kmeans.stream.estimate(graphNameOrConfiguration :: ANY?, al│
│                                                              │                                                                      │goConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: ST│
│                                                              │                                                                      │RING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, no│
│                                                              │                                                                      │deCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin │
│                                                              │                                                                      │:: FLOAT?, heapPercentageMax :: FLOAT?)"                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.kmeans.write"                                      │"The Kmeans  algorithm clusters nodes into different communities based│"gds.alpha.kmeans.write(graphName :: STRING?, configuration = {} :: MA│
│                                                              │ on Euclidean distance"                                               │P?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, co│
│                                                              │                                                                      │mmunityDistribution :: MAP?, centroids :: LIST? OF LIST? OF FLOAT?, av│
│                                                              │                                                                      │erageDistanceToCentroid :: FLOAT?, averageSilhouette :: FLOAT?, postPr│
│                                                              │                                                                      │ocessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMi│
│                                                              │                                                                      │llis :: INTEGER?, configuration :: MAP?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.kmeans.write.estimate"                             │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.kmeans.write.estimate(graphNameOrConfiguration :: ANY?, alg│
│                                                              │                                                                      │oConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STR│
│                                                              │                                                                      │ING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :│
│                                                              │                                                                      │: FLOAT?, heapPercentageMax :: FLOAT?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.knn.filtered.mutate"                               │"The k-nearest neighbor graph algorithm constructs relationships betwe│"gds.alpha.knn.filtered.mutate(graphName :: STRING?, configuration = {│
│                                                              │en nodes if the distance between two nodes is among the k nearest dist│} :: MAP?) :: (ranIterations :: INTEGER?, nodePairsConsidered :: INTEG│
│                                                              │ances compared to other nodes. KNN computes distances based on the sim│ER?, didConverge :: BOOLEAN?, preProcessingMillis :: INTEGER?, compute│
│                                                              │ilarity of node properties. Filtered KNN extends this functionality, a│Millis :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: │
│                                                              │llowing filtering on source nodes and target nodes, respectively."    │INTEGER?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?,│
│                                                              │                                                                      │ similarityDistribution :: MAP?, configuration :: MAP?)"              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.knn.filtered.stats"                                │"Executes the algorithm and returns result statistics without writing │"gds.alpha.knn.filtered.stats(graphName :: STRING?, configuration = {}│
│                                                              │the result to Neo4j."                                                 │ :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, node│
│                                                              │                                                                      │PairsConsidered :: INTEGER?, preProcessingMillis :: INTEGER?, computeM│
│                                                              │                                                                      │illis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: │
│                                                              │                                                                      │INTEGER?, similarityPairs :: INTEGER?, similarityDistribution :: MAP?,│
│                                                              │                                                                      │ configuration :: MAP?)"                                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.knn.filtered.stream"                               │"The k-nearest neighbor graph algorithm constructs relationships betwe│"gds.alpha.knn.filtered.stream(graphName :: STRING?, configuration = {│
│                                                              │en nodes if the distance between two nodes is among the k nearest dist│} :: MAP?) :: (node1 :: INTEGER?, node2 :: INTEGER?, similarity :: FLO│
│                                                              │ances compared to other nodes. KNN computes distances based on the sim│AT?)"                                                                 │
│                                                              │ilarity of node properties. Filtered KNN extends this functionality, a│                                                                      │
│                                                              │llowing filtering on source nodes and target nodes, respectively."    │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.knn.filtered.write"                                │"The k-nearest neighbor graph algorithm constructs relationships betwe│"gds.alpha.knn.filtered.write(graphName :: STRING?, configuration = {}│
│                                                              │en nodes if the distance between two nodes is among the k nearest dist│ :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, node│
│                                                              │ances compared to other nodes. KNN computes distances based on the sim│PairsConsidered :: INTEGER?, preProcessingMillis :: INTEGER?, computeM│
│                                                              │ilarity of node properties. Filtered KNN extends this functionality, a│illis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: IN│
│                                                              │llowing filtering on source nodes and target nodes, respectively."    │TEGER?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?, s│
│                                                              │                                                                      │imilarityDistribution :: MAP?, configuration :: MAP?)"                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.leiden.mutate"                                     │"Leiden is a community detection algorithm, which guarantees that comm│"gds.alpha.leiden.mutate(graphName :: STRING?, configuration = {} :: M│
│                                                              │unities are well connected"                                           │AP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, │
│                                                              │                                                                      │ranLevels :: INTEGER?, didConverge :: BOOLEAN?, nodeCount :: INTEGER?,│
│                                                              │                                                                      │ communityCount :: INTEGER?, communityDistribution :: MAP?, modularity│
│                                                              │                                                                      │ :: FLOAT?, modularities :: LIST? OF FLOAT?, postProcessingMillis :: I│
│                                                              │                                                                      │NTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, c│
│                                                              │                                                                      │onfiguration :: MAP?)"                                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.leiden.stats"                                      │"Executes the algorithm and returns result statistics without writing │"gds.alpha.leiden.stats(graphName :: STRING?, configuration = {} :: MA│
│                                                              │the result to Neo4j."                                                 │P?) :: (ranLevels :: INTEGER?, didConverge :: BOOLEAN?, nodeCount :: I│
│                                                              │                                                                      │NTEGER?, communityCount :: INTEGER?, communityDistribution :: MAP?, mo│
│                                                              │                                                                      │dularity :: FLOAT?, modularities :: LIST? OF FLOAT?, postProcessingMil│
│                                                              │                                                                      │lis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INT│
│                                                              │                                                                      │EGER?, configuration :: MAP?)"                                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.leiden.stream"                                     │"Leiden is a community detection algorithm, which guarantees that comm│"gds.alpha.leiden.stream(graphName :: STRING?, configuration = {} :: M│
│                                                              │unities are well connected"                                           │AP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?, intermediateComm│
│                                                              │                                                                      │unityIds :: LIST? OF INTEGER?)"                                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.leiden.write"                                      │"Leiden is a community detection algorithm, which guarantees that comm│"gds.alpha.leiden.write(graphName :: STRING?, configuration = {} :: MA│
│                                                              │unities are well connected"                                           │P?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ra│
│                                                              │                                                                      │nLevels :: INTEGER?, didConverge :: BOOLEAN?, nodeCount :: INTEGER?, c│
│                                                              │                                                                      │ommunityCount :: INTEGER?, communityDistribution :: MAP?, modularity :│
│                                                              │                                                                      │: FLOAT?, modularities :: LIST? OF FLOAT?, postProcessingMillis :: INT│
│                                                              │                                                                      │EGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, con│
│                                                              │                                                                      │figuration :: MAP?)"                                                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.maxkcut.mutate"                                    │"Approximate Maximum k-cut maps each node into one of k disjoint commu│"gds.alpha.maxkcut.mutate(graphName :: STRING?, configuration = {} :: │
│                                                              │nities trying to maximize the sum of weights of relationships between │MAP?) :: (nodePropertiesWritten :: INTEGER?, cutCost :: FLOAT?, mutate│
│                                                              │these communities."                                                   │Millis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMil│
│                                                              │                                                                      │lis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.maxkcut.mutate.estimate"                           │"Approximate Maximum k-cut maps each node into one of k disjoint commu│"gds.alpha.maxkcut.mutate.estimate(graphNameOrConfiguration :: ANY?, a│
│                                                              │nities trying to maximize the sum of weights of relationships between │lgoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: S│
│                                                              │these communities."                                                   │TRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, n│
│                                                              │                                                                      │odeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin│
│                                                              │                                                                      │ :: FLOAT?, heapPercentageMax :: FLOAT?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.maxkcut.stream"                                    │"Approximate Maximum k-cut maps each node into one of k disjoint commu│"gds.alpha.maxkcut.stream(graphName :: STRING?, configuration = {} :: │
│                                                              │nities trying to maximize the sum of weights of relationships between │MAP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?)"               │
│                                                              │these communities."                                                   │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.maxkcut.stream.estimate"                           │"Approximate Maximum k-cut maps each node into one of k disjoint commu│"gds.alpha.maxkcut.stream.estimate(graphNameOrConfiguration :: ANY?, a│
│                                                              │nities trying to maximize the sum of weights of relationships between │lgoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: S│
│                                                              │these communities."                                                   │TRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, n│
│                                                              │                                                                      │odeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin│
│                                                              │                                                                      │ :: FLOAT?, heapPercentageMax :: FLOAT?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.ml.splitRelationships.mutate"                      │"Splits a graph into holdout and remaining relationship types and adds│"gds.alpha.ml.splitRelationships.mutate(graphName :: STRING?, configur│
│                                                              │ them to the graph."                                                  │ation = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis│
│                                                              │                                                                      │ :: INTEGER?, mutateMillis :: INTEGER?, relationshipsWritten :: INTEGE│
│                                                              │                                                                      │R?, configuration :: MAP?)"                                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.model.delete"                                      │"Deletes a stored model from disk."                                   │"gds.alpha.model.delete(modelName :: STRING?) :: (modelName :: STRING?│
│                                                              │                                                                      │, deleteMillis :: INTEGER?)"                                          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.model.load"                                        │"Load a stored model into main memory."                               │"gds.alpha.model.load(modelName :: STRING?) :: (modelName :: STRING?, │
│                                                              │                                                                      │loadMillis :: INTEGER?)"                                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.model.publish"                                     │"Make a trained model accessible by all users"                        │"gds.alpha.model.publish(modelName :: STRING?) :: (modelInfo :: MAP?, │
│                                                              │                                                                      │trainConfig :: MAP?, graphSchema :: MAP?, loaded :: BOOLEAN?, stored :│
│                                                              │                                                                      │: BOOLEAN?, creationTime :: DATETIME?, shared :: BOOLEAN?)"           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.model.store"                                       │"Store the selected model to disk."                                   │"gds.alpha.model.store(modelName :: STRING?, failIfUnsupported = true │
│                                                              │                                                                      │:: BOOLEAN?) :: (modelName :: STRING?, storeMillis :: INTEGER?)"      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.modularity.stats"                                  │"TODO: Add modularity description"                                    │"gds.alpha.modularity.stats(graphName :: STRING?, configuration = {} :│
│                                                              │                                                                      │: MAP?) :: (nodeCount :: INTEGER?, relationshipCount :: INTEGER?, comm│
│                                                              │                                                                      │unityCount :: INTEGER?, modularity :: FLOAT?, postProcessingMillis :: │
│                                                              │                                                                      │INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, │
│                                                              │                                                                      │configuration :: MAP?)"                                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.modularity.stream"                                 │"TODO: Add modularity description"                                    │"gds.alpha.modularity.stream(graphName :: STRING?, configuration = {} │
│                                                              │                                                                      │:: MAP?) :: (communityId :: INTEGER?, modularity :: FLOAT?)"          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.nodeSimilarity.filtered.mutate"                    │"The Filtered Node Similarity algorithm compares a set of nodes based │"gds.alpha.nodeSimilarity.filtered.mutate(graphName :: STRING?, config│
│                                                              │on the nodes they are connected to. Two nodes are considered similar i│uration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMill│
│                                                              │f they share many of the same neighbors. The algorithm computes pair-w│is :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTE│
│                                                              │ise similarities based on Jaccard or Overlap metrics. The filtered var│GER?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?, sim│
│                                                              │iant supports limiting which nodes to compare via source and target no│ilarityDistribution :: MAP?, configuration :: MAP?)"                  │
│                                                              │de filters."                                                          │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.nodeSimilarity.filtered.mutate.estimate"           │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.nodeSimilarity.filtered.mutate.estimate(graphNameOrConfigur│
│                                                              │                                                                      │ation :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING│
│                                                              │                                                                      │?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMa│
│                                                              │                                                                      │x :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, h│
│                                                              │                                                                      │eapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.nodeSimilarity.filtered.stats"                     │"The Filtered Node Similarity algorithm compares a set of nodes based │"gds.alpha.nodeSimilarity.filtered.stats(graphName :: STRING?, configu│
│                                                              │on the nodes they are connected to. Two nodes are considered similar i│ration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMilli│
│                                                              │f they share many of the same neighbors. The algorithm computes pair-w│s :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTE│
│                                                              │ise similarities based on Jaccard or Overlap metrics. The filtered var│GER?, similarityPairs :: INTEGER?, similarityDistribution :: MAP?, con│
│                                                              │iant supports limiting which nodes to compare via source and target no│figuration :: MAP?)"                                                  │
│                                                              │de filters."                                                          │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.nodeSimilarity.filtered.stats.estimate"            │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.nodeSimilarity.filtered.stats.estimate(graphNameOrConfigura│
│                                                              │                                                                      │tion :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?│
│                                                              │                                                                      │, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax│
│                                                              │                                                                      │ :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, he│
│                                                              │                                                                      │apPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.nodeSimilarity.filtered.stream"                    │"The Filtered Node Similarity algorithm compares a set of nodes based │"gds.alpha.nodeSimilarity.filtered.stream(graphName :: STRING?, config│
│                                                              │on the nodes they are connected to. Two nodes are considered similar i│uration = {} :: MAP?) :: (node1 :: INTEGER?, node2 :: INTEGER?, simila│
│                                                              │f they share many of the same neighbors. The algorithm computes pair-w│rity :: FLOAT?)"                                                      │
│                                                              │ise similarities based on Jaccard or Overlap metrics. The filtered var│                                                                      │
│                                                              │iant supports limiting which nodes to compare via source and target no│                                                                      │
│                                                              │de filters."                                                          │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.nodeSimilarity.filtered.stream.estimate"           │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.nodeSimilarity.filtered.stream.estimate(graphNameOrConfigur│
│                                                              │                                                                      │ation :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING│
│                                                              │                                                                      │?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMa│
│                                                              │                                                                      │x :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, h│
│                                                              │                                                                      │eapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.nodeSimilarity.filtered.write"                     │"The Filtered Node Similarity algorithm compares a set of nodes based │"gds.alpha.nodeSimilarity.filtered.write(graphName :: STRING?, configu│
│                                                              │on the nodes they are connected to. Two nodes are considered similar i│ration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMilli│
│                                                              │f they share many of the same neighbors. The algorithm computes pair-w│s :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGE│
│                                                              │ise similarities based on Jaccard or Overlap metrics. The filtered var│R?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?, simil│
│                                                              │iant supports limiting which nodes to compare via source and target no│arityDistribution :: MAP?, configuration :: MAP?)"                    │
│                                                              │de filters."                                                          │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.nodeSimilarity.filtered.write.estimate"            │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.nodeSimilarity.filtered.write.estimate(graphNameOrConfigura│
│                                                              │                                                                      │tion :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?│
│                                                              │                                                                      │, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax│
│                                                              │                                                                      │ :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, he│
│                                                              │                                                                      │apPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.linkPrediction.addMLP"                    │"Add a multilayer perceptron configuration to the parameter space of t│"gds.alpha.pipeline.linkPrediction.addMLP(pipelineName :: STRING?, con│
│                                                              │he link prediction train pipeline."                                   │fig = {} :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? OF M│
│                                                              │                                                                      │AP?, featureSteps :: LIST? OF MAP?, splitConfig :: MAP?, autoTuningCon│
│                                                              │                                                                      │fig :: MAP?, parameterSpace :: ANY?)"                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.linkPrediction.addRandomForest"           │"Add a random forest configuration to the parameter space of the link │"gds.alpha.pipeline.linkPrediction.addRandomForest(pipelineName :: STR│
│                                                              │prediction train pipeline."                                           │ING?, config :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? │
│                                                              │                                                                      │OF MAP?, featureSteps :: LIST? OF MAP?, splitConfig :: MAP?, autoTunin│
│                                                              │                                                                      │gConfig :: MAP?, parameterSpace :: ANY?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.linkPrediction.configureAutoTuning"       │"Configures the auto-tuning of the link prediction pipeline."         │"gds.alpha.pipeline.linkPrediction.configureAutoTuning(pipelineName ::│
│                                                              │                                                                      │ STRING?, configuration :: MAP?) :: (name :: STRING?, nodePropertyStep│
│                                                              │                                                                      │s :: LIST? OF MAP?, featureSteps :: LIST? OF MAP?, splitConfig :: MAP?│
│                                                              │                                                                      │, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeClassification.addMLP"                │"Add a multilayer perceptron configuration to the parameter space of t│"gds.alpha.pipeline.nodeClassification.addMLP(pipelineName :: STRING?,│
│                                                              │he node classification train pipeline."                               │ config = {} :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? │
│                                                              │                                                                      │OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig :: MAP?, a│
│                                                              │                                                                      │utoTuningConfig :: MAP?, parameterSpace :: ANY?)"                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeClassification.addRandomForest"       │"Add a random forest configuration to the parameter space of the node │"gds.alpha.pipeline.nodeClassification.addRandomForest(pipelineName ::│
│                                                              │classification train pipeline."                                       │ STRING?, config :: MAP?) :: (name :: STRING?, nodePropertySteps :: LI│
│                                                              │                                                                      │ST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig :: MAP│
│                                                              │                                                                      │?, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeClassification.configureAutoTuning"   │"Configures the auto-tuning of the node classification pipeline."     │"gds.alpha.pipeline.nodeClassification.configureAutoTuning(pipelineNam│
│                                                              │                                                                      │e :: STRING?, configuration :: MAP?) :: (name :: STRING?, nodeProperty│
│                                                              │                                                                      │Steps :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitCo│
│                                                              │                                                                      │nfig :: MAP?, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeRegression.addLinearRegression"       │"Add a linear regression model candidate to a node regression pipeline│"gds.alpha.pipeline.nodeRegression.addLinearRegression(pipelineName ::│
│                                                              │."                                                                    │ STRING?, configuration = {} :: MAP?) :: (name :: STRING?, nodePropert│
│                                                              │                                                                      │ySteps :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitC│
│                                                              │                                                                      │onfig :: MAP?, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeRegression.addNodeProperty"           │"Add a node property step to an existing node regression training pipe│"gds.alpha.pipeline.nodeRegression.addNodeProperty(pipelineName :: STR│
│                                                              │line."                                                                │ING?, procedureName :: STRING?, procedureConfiguration :: MAP?) :: (na│
│                                                              │                                                                      │me :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureProperties :│
│                                                              │                                                                      │: LIST? OF STRING?, splitConfig :: MAP?, autoTuningConfig :: MAP?, par│
│                                                              │                                                                      │ameterSpace :: ANY?)"                                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeRegression.addRandomForest"           │"Add a random forest model candidate to a node regression pipeline."  │"gds.alpha.pipeline.nodeRegression.addRandomForest(pipelineName :: STR│
│                                                              │                                                                      │ING?, configuration :: MAP?) :: (name :: STRING?, nodePropertySteps ::│
│                                                              │                                                                      │ LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig :: │
│                                                              │                                                                      │MAP?, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeRegression.configureAutoTuning"       │"Configures the auto-tuning of a node regression pipeline."           │"gds.alpha.pipeline.nodeRegression.configureAutoTuning(pipelineName ::│
│                                                              │                                                                      │ STRING?, configuration :: MAP?) :: (name :: STRING?, nodePropertyStep│
│                                                              │                                                                      │s :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig│
│                                                              │                                                                      │ :: MAP?, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeRegression.configureSplit"            │"Configures the graph splitting of a node regression pipeline."       │"gds.alpha.pipeline.nodeRegression.configureSplit(pipelineName :: STRI│
│                                                              │                                                                      │NG?, configuration :: MAP?) :: (name :: STRING?, nodePropertySteps :: │
│                                                              │                                                                      │LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig :: M│
│                                                              │                                                                      │AP?, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeRegression.create"                    │"Creates a node regression training pipeline in the pipeline catalog."│"gds.alpha.pipeline.nodeRegression.create(pipelineName :: STRING?) :: │
│                                                              │                                                                      │(name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featurePropertie│
│                                                              │                                                                      │s :: LIST? OF STRING?, splitConfig :: MAP?, autoTuningConfig :: MAP?, │
│                                                              │                                                                      │parameterSpace :: ANY?)"                                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeRegression.predict.mutate"            │"Predicts target node property using a previously trained `NodeRegress│"gds.alpha.pipeline.nodeRegression.predict.mutate(graphName :: STRING?│
│                                                              │ion` model"                                                           │, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, m│
│                                                              │                                                                      │utateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessi│
│                                                              │                                                                      │ngMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?│
│                                                              │                                                                      │)"                                                                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeRegression.predict.stream"            │"Predicts target node property using a previously trained `NodeRegress│"gds.alpha.pipeline.nodeRegression.predict.stream(graphName :: STRING?│
│                                                              │ion` model"                                                           │, configuration :: MAP?) :: (nodeId :: INTEGER?, predictedValue :: FLO│
│                                                              │                                                                      │AT?)"                                                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeRegression.selectFeatures"            │"Add one or several features to an existing node regression training p│"gds.alpha.pipeline.nodeRegression.selectFeatures(pipelineName :: STRI│
│                                                              │ipeline."                                                             │NG?, featureProperties :: ANY?) :: (name :: STRING?, nodePropertySteps│
│                                                              │                                                                      │ :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig │
│                                                              │                                                                      │:: MAP?, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.pipeline.nodeRegression.train"                     │"Trains a node classification model based on a pipeline"              │"gds.alpha.pipeline.nodeRegression.train(graphName :: STRING?, configu│
│                                                              │                                                                      │ration = {} :: MAP?) :: (modelSelectionStats :: MAP?, trainMillis :: I│
│                                                              │                                                                      │NTEGER?, modelInfo :: MAP?, configuration :: MAP?)"                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.restore"                                           │"The restore procedure reads graphs and models from disk."            │"gds.alpha.restore(configuration = {} :: MAP?) :: (restoredGraph :: ST│
│                                                              │                                                                      │RING?, restoredModel :: STRING?, status :: STRING?, restoreMillis :: I│
│                                                              │                                                                      │NTEGER?)"                                                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.scaleProperties.mutate"                            │"Scale node properties"                                               │"gds.alpha.scaleProperties.mutate(graphName :: STRING?, configuration │
│                                                              │                                                                      │= {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: I│
│                                                              │                                                                      │NTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTE│
│                                                              │                                                                      │GER?, computeMillis :: INTEGER?, configuration :: MAP?)"              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.scaleProperties.stream"                            │"Scale node properties"                                               │"gds.alpha.scaleProperties.stream(graphName :: STRING?, configuration │
│                                                              │                                                                      │= {} :: MAP?) :: (nodeId :: INTEGER?, scaledProperty :: LIST? OF FLOAT│
│                                                              │                                                                      │?)"                                                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.scc.stream"                                        │"The SCC algorithm finds sets of connected nodes in an directed graph,│"gds.alpha.scc.stream(graphName :: STRING?, configuration = {} :: MAP?│
│                                                              │ where all nodes in the same set form a connected component."         │) :: (nodeId :: INTEGER?, componentId :: INTEGER?)"                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.scc.write"                                         │"The SCC algorithm finds sets of connected nodes in an directed graph,│"gds.alpha.scc.write(graphName :: STRING?, configuration = {} :: MAP?)│
│                                                              │ where all nodes in the same set form a connected component."         │ :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, write│
│                                                              │                                                                      │Millis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER│
│                                                              │                                                                      │?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INT│
│                                                              │                                                                      │EGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: │
│                                                              │                                                                      │INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: IN│
│                                                              │                                                                      │TEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, writePrope│
│                                                              │                                                                      │rty :: STRING?)"                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.sllpa.mutate"                                      │"The Speaker Listener Label Propagation algorithm is a fast algorithm │"gds.alpha.sllpa.mutate(graphName :: STRING?, configuration = {} :: MA│
│                                                              │for finding overlapping communities in a graph."                      │P?) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, │
│                                                              │                                                                      │didConverge :: BOOLEAN?, mutateMillis :: INTEGER?, postProcessingMilli│
│                                                              │                                                                      │s :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEG│
│                                                              │                                                                      │ER?, configuration :: MAP?)"                                          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.sllpa.mutate.estimate"                             │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.sllpa.mutate.estimate(graphNameOrConfiguration :: ANY?, alg│
│                                                              │                                                                      │oConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STR│
│                                                              │                                                                      │ING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :│
│                                                              │                                                                      │: FLOAT?, heapPercentageMax :: FLOAT?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.sllpa.stats"                                       │"The Speaker Listener Label Propagation algorithm is a fast algorithm │"gds.alpha.sllpa.stats(graphName :: STRING?, configuration = {} :: MAP│
│                                                              │for finding overlapping communities in a graph."                      │?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, postProcess│
│                                                              │                                                                      │ingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis │
│                                                              │                                                                      │:: INTEGER?, configuration :: MAP?)"                                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.sllpa.stats.estimate"                              │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.sllpa.stats.estimate(graphNameOrConfiguration :: ANY?, algo│
│                                                              │                                                                      │Configuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRI│
│                                                              │                                                                      │NG?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin ::│
│                                                              │                                                                      │ FLOAT?, heapPercentageMax :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.sllpa.stream"                                      │"The Speaker Listener Label Propagation algorithm is a fast algorithm │"gds.alpha.sllpa.stream(graphName :: STRING?, configuration = {} :: MA│
│                                                              │for finding overlapping communities in a graph."                      │P?) :: (nodeId :: INTEGER?, values :: MAP?)"                          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.sllpa.stream.estimate"                             │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.sllpa.stream.estimate(graphNameOrConfiguration :: ANY?, alg│
│                                                              │                                                                      │oConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STR│
│                                                              │                                                                      │ING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :│
│                                                              │                                                                      │: FLOAT?, heapPercentageMax :: FLOAT?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.sllpa.write"                                       │"The Speaker Listener Label Propagation algorithm is a fast algorithm │"gds.alpha.sllpa.write(graphName :: STRING?, configuration = {} :: MAP│
│                                                              │for finding overlapping communities in a graph."                      │?) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, d│
│                                                              │                                                                      │idConverge :: BOOLEAN?, writeMillis :: INTEGER?, postProcessingMillis │
│                                                              │                                                                      │:: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER│
│                                                              │                                                                      │?, configuration :: MAP?)"                                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.sllpa.write.estimate"                              │"Returns an estimation of the memory consumption for that procedure." │"gds.alpha.sllpa.write.estimate(graphNameOrConfiguration :: ANY?, algo│
│                                                              │                                                                      │Configuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRI│
│                                                              │                                                                      │NG?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin ::│
│                                                              │                                                                      │ FLOAT?, heapPercentageMax :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.spanningTree.kmax.write"                           │"The maximum weight spanning tree (MST) starts from a given node, and │"gds.alpha.spanningTree.kmax.write(graphName :: STRING?, configuration│
│                                                              │finds all its reachable nodes and the set of relationships that connec│ = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: I│
│                                                              │t the nodes together with the maximum possible weight."               │NTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.spanningTree.kmin.write"                           │"The minimum weight spanning tree (MST) starts from a given node, and │"gds.alpha.spanningTree.kmin.write(graphName :: STRING?, configuration│
│                                                              │finds all its reachable nodes and the set of relationships that connec│ = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: I│
│                                                              │t the nodes together with the minimum possible weight."               │NTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.spanningTree.maximum.write"                        │"Maximum weight spanning tree visits all nodes that are in the same co│"gds.alpha.spanningTree.maximum.write(graphName :: STRING?, configurat│
│                                                              │nnected component as the starting node, and returns a spanning tree of│ion = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :│
│                                                              │ all nodes in the component where the total weight of the relationship│: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)" │
│                                                              │s is maximized."                                                      │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.spanningTree.minimum.write"                        │"Minimum weight spanning tree visits all nodes that are in the same co│"gds.alpha.spanningTree.minimum.write(graphName :: STRING?, configurat│
│                                                              │nnected component as the starting node, and returns a spanning tree of│ion = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :│
│                                                              │ all nodes in the component where the total weight of the relationship│: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)" │
│                                                              │s is minimized."                                                      │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.spanningTree.write"                                │"Minimum weight spanning tree visits all nodes that are in the same co│"gds.alpha.spanningTree.write(graphName :: STRING?, configuration = {}│
│                                                              │nnected component as the starting node, and returns a spanning tree of│ :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGE│
│                                                              │ all nodes in the component where the total weight of the relationship│R?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"         │
│                                                              │s is minimized."                                                      │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.systemMonitor"                                     │"Get an overview of the system's workload and available resources"    │"gds.alpha.systemMonitor() :: (freeHeap :: INTEGER?, totalHeap :: INTE│
│                                                              │                                                                      │GER?, maxHeap :: INTEGER?, jvmAvailableCpuCores :: INTEGER?, available│
│                                                              │                                                                      │CpuCoresNotRequested :: INTEGER?, jvmHeapStatus :: MAP?, ongoingGdsPro│
│                                                              │                                                                      │cedures :: LIST? OF MAP?)"                                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.triangles"                                         │"Triangles streams the nodeIds of each triangle in the graph."        │"gds.alpha.triangles(graphName :: STRING?, configuration = {} :: MAP?)│
│                                                              │                                                                      │ :: (nodeA :: INTEGER?, nodeB :: INTEGER?, nodeC :: INTEGER?)"        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.alpha.userLog"                                           │"Log warnings and hints for currently running tasks."                 │"gds.alpha.userLog(jobId =  :: STRING?) :: (taskName :: STRING?, messa│
│                                                              │                                                                      │ge :: STRING?, timeStarted :: LOCALTIME?)"                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.articleRank.mutate"                                      │"Article Rank is a variant of the Page Rank algorithm, which measures │"gds.articleRank.mutate(graphName :: STRING?, configuration = {} :: MA│
│                                                              │the transitive influence or connectivity of nodes."                   │P?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, r│
│                                                              │                                                                      │anIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribut│
│                                                              │                                                                      │ion :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: │
│                                                              │                                                                      │INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.articleRank.mutate.estimate"                             │"Returns an estimation of the memory consumption for that procedure." │"gds.articleRank.mutate.estimate(graphNameOrConfiguration :: ANY?, alg│
│                                                              │                                                                      │oConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STR│
│                                                              │                                                                      │ING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :│
│                                                              │                                                                      │: FLOAT?, heapPercentageMax :: FLOAT?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.articleRank.stats"                                       │"Executes the algorithm and returns result statistics without writing │"gds.articleRank.stats(graphName :: STRING?, configuration = {} :: MAP│
│                                                              │the result to Neo4j."                                                 │?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityD│
│                                                              │                                                                      │istribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMi│
│                                                              │                                                                      │llis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.articleRank.stats.estimate"                              │"Returns an estimation of the memory consumption for that procedure." │"gds.articleRank.stats.estimate(graphNameOrConfiguration :: ANY?, algo│
│                                                              │                                                                      │Configuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRI│
│                                                              │                                                                      │NG?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin ::│
│                                                              │                                                                      │ FLOAT?, heapPercentageMax :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.articleRank.stream"                                      │"Article Rank is a variant of the Page Rank algorithm, which measures │"gds.articleRank.stream(graphName :: STRING?, configuration = {} :: MA│
│                                                              │the transitive influence or connectivity of nodes."                   │P?) :: (nodeId :: INTEGER?, score :: FLOAT?)"                         │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.articleRank.stream.estimate"                             │"Returns an estimation of the memory consumption for that procedure." │"gds.articleRank.stream.estimate(graphNameOrConfiguration :: ANY?, alg│
│                                                              │                                                                      │oConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STR│
│                                                              │                                                                      │ING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :│
│                                                              │                                                                      │: FLOAT?, heapPercentageMax :: FLOAT?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.articleRank.write"                                       │"Article Rank is a variant of the Page Rank algorithm, which measures │"gds.articleRank.write(graphName :: STRING?, configuration = {} :: MAP│
│                                                              │the transitive influence or connectivity of nodes."                   │?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ran│
│                                                              │                                                                      │Iterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistributio│
│                                                              │                                                                      │n :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: IN│
│                                                              │                                                                      │TEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.articleRank.write.estimate"                              │"Returns an estimation of the memory consumption for that procedure." │"gds.articleRank.write.estimate(graphNameOrConfiguration :: ANY?, algo│
│                                                              │                                                                      │Configuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRI│
│                                                              │                                                                      │NG?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin ::│
│                                                              │                                                                      │ FLOAT?, heapPercentageMax :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.closeness.mutate"                                   │"Closeness centrality is a way of detecting nodes that are able to spr│"gds.beta.closeness.mutate(graphName :: STRING?, configuration = {} ::│
│                                                              │ead information very efficiently through a graph."                    │ MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateProperty :: STRING│
│                                                              │                                                                      │?, centralityDistribution :: MAP?, mutateMillis :: INTEGER?, postProce│
│                                                              │                                                                      │ssingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMilli│
│                                                              │                                                                      │s :: INTEGER?, configuration :: MAP?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.closeness.stats"                                    │"Closeness centrality is a way of detecting nodes that are able to spr│"gds.beta.closeness.stats(graphName :: STRING?, configuration = {} :: │
│                                                              │ead information very efficiently through a graph."                    │MAP?) :: (centralityDistribution :: MAP?, postProcessingMillis :: INTE│
│                                                              │                                                                      │GER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, conf│
│                                                              │                                                                      │iguration :: MAP?)"                                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.closeness.stream"                                   │"Closeness centrality is a way of detecting nodes that are able to spr│"gds.beta.closeness.stream(graphName :: STRING?, configuration = {} ::│
│                                                              │ead information very efficiently through a graph."                    │ MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.closeness.write"                                    │"Closeness centrality is a way of detecting nodes that are able to spr│"gds.beta.closeness.write(graphName :: STRING?, configuration = {} :: │
│                                                              │ead information very efficiently through a graph."                    │MAP?) :: (nodePropertiesWritten :: INTEGER?, writeProperty :: STRING?,│
│                                                              │                                                                      │ centralityDistribution :: MAP?, writeMillis :: INTEGER?, postProcessi│
│                                                              │                                                                      │ngMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :│
│                                                              │                                                                      │: INTEGER?, configuration :: MAP?)"                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.collapsePath.mutate"                                │"Collapse Path algorithm is a traversal algorithm capable of creating │"gds.beta.collapsePath.mutate(graphName :: STRING?, configuration = {}│
│                                                              │relationships between the start and end nodes of a traversal"         │ :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGE│
│                                                              │                                                                      │R?, mutateMillis :: INTEGER?, relationshipsWritten :: INTEGER?, config│
│                                                              │                                                                      │uration :: MAP?)"                                                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graph.export.csv"                                   │"Exports a named graph to CSV files."                                 │"gds.beta.graph.export.csv(graphName :: STRING?, configuration = {} ::│
│                                                              │                                                                      │ MAP?) :: (exportName :: STRING?, graphName :: STRING?, nodeCount :: I│
│                                                              │                                                                      │NTEGER?, relationshipCount :: INTEGER?, relationshipTypeCount :: INTEG│
│                                                              │                                                                      │ER?, nodePropertyCount :: INTEGER?, relationshipPropertyCount :: INTEG│
│                                                              │                                                                      │ER?, writeMillis :: INTEGER?)"                                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graph.export.csv.estimate"                          │"Estimate the required disk space for exporting a named graph to CSV f│"gds.beta.graph.export.csv.estimate(graphName :: STRING?, configuratio│
│                                                              │iles."                                                                │n = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, ma│
│                                                              │                                                                      │pView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :│
│                                                              │                                                                      │: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?│
│                                                              │                                                                      │, heapPercentageMax :: FLOAT?)"                                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graph.generate"                                     │"Computes a random graph, which will be stored in the graph catalog." │"gds.beta.graph.generate(graphName :: STRING?, nodeCount :: INTEGER?, │
│                                                              │                                                                      │averageDegree :: INTEGER?, configuration = {} :: MAP?) :: (name :: STR│
│                                                              │                                                                      │ING?, nodes :: INTEGER?, relationships :: INTEGER?, generateMillis :: │
│                                                              │                                                                      │INTEGER?, relationshipSeed :: INTEGER?, averageDegree :: FLOAT?, relat│
│                                                              │                                                                      │ionshipDistribution :: ANY?, relationshipProperty :: ANY?)"           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graph.project.subgraph"                             │"Creates a named graph in the catalog for use by algorithms."         │"gds.beta.graph.project.subgraph(graphName :: STRING?, fromGraphName :│
│                                                              │                                                                      │: STRING?, nodeFilter :: STRING?, relationshipFilter :: STRING?, confi│
│                                                              │                                                                      │guration = {} :: MAP?) :: (fromGraphName :: STRING?, nodeFilter :: STR│
│                                                              │                                                                      │ING?, relationshipFilter :: STRING?, graphName :: STRING?, nodeCount :│
│                                                              │                                                                      │: INTEGER?, relationshipCount :: INTEGER?, projectMillis :: INTEGER?)"│
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graph.relationships.stream"                         │"Streams the given relationship source/target pairs"                  │"gds.beta.graph.relationships.stream(graphName :: STRING?, relationshi│
│                                                              │                                                                      │pTypes = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (sour│
│                                                              │                                                                      │ceNodeId :: INTEGER?, targetNodeId :: INTEGER?, relationshipType :: ST│
│                                                              │                                                                      │RING?)"                                                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graphSage.mutate"                                   │"The GraphSage algorithm inductively computes embeddings for nodes bas│"gds.beta.graphSage.mutate(graphName :: STRING?, configuration = {} ::│
│                                                              │ed on a their features and neighborhoods."                            │ MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?│
│                                                              │                                                                      │, nodeCount :: INTEGER?, preProcessingMillis :: INTEGER?, computeMilli│
│                                                              │                                                                      │s :: INTEGER?, configuration :: MAP?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graphSage.mutate.estimate"                          │"The GraphSage algorithm inductively computes embeddings for nodes bas│"gds.beta.graphSage.mutate.estimate(graphNameOrConfiguration :: ANY?, │
│                                                              │ed on a their features and neighborhoods."                            │algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: │
│                                                              │                                                                      │STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, │
│                                                              │                                                                      │nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMi│
│                                                              │                                                                      │n :: FLOAT?, heapPercentageMax :: FLOAT?)"                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graphSage.stream"                                   │"The GraphSage algorithm inductively computes embeddings for nodes bas│"gds.beta.graphSage.stream(graphName :: STRING?, configuration = {} ::│
│                                                              │ed on a their features and neighborhoods."                            │ MAP?) :: (nodeId :: INTEGER?, embedding :: LIST? OF FLOAT?)"         │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graphSage.stream.estimate"                          │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.graphSage.stream.estimate(graphNameOrConfiguration :: ANY?, │
│                                                              │                                                                      │algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: │
│                                                              │                                                                      │STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, │
│                                                              │                                                                      │nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMi│
│                                                              │                                                                      │n :: FLOAT?, heapPercentageMax :: FLOAT?)"                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graphSage.train"                                    │"The GraphSage algorithm inductively computes embeddings for nodes bas│"gds.beta.graphSage.train(graphName :: STRING?, configuration = {} :: │
│                                                              │ed on a their features and neighborhoods."                            │MAP?) :: (modelInfo :: MAP?, configuration :: MAP?, trainMillis :: INT│
│                                                              │                                                                      │EGER?)"                                                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graphSage.train.estimate"                           │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.graphSage.train.estimate(graphNameOrConfiguration :: ANY?, a│
│                                                              │                                                                      │lgoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: S│
│                                                              │                                                                      │TRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, n│
│                                                              │                                                                      │odeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin│
│                                                              │                                                                      │ :: FLOAT?, heapPercentageMax :: FLOAT?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graphSage.write"                                    │"The GraphSage algorithm inductively computes embeddings for nodes bas│"gds.beta.graphSage.write(graphName :: STRING?, configuration = {} :: │
│                                                              │ed on a their features and neighborhoods."                            │MAP?) :: (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, pr│
│                                                              │                                                                      │eProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis │
│                                                              │                                                                      │:: INTEGER?, configuration :: MAP?)"                                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.graphSage.write.estimate"                           │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.graphSage.write.estimate(graphNameOrConfiguration :: ANY?, a│
│                                                              │                                                                      │lgoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: S│
│                                                              │                                                                      │TRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, n│
│                                                              │                                                                      │odeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin│
│                                                              │                                                                      │ :: FLOAT?, heapPercentageMax :: FLOAT?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.influenceMaximization.celf.mutate"                  │"The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes│"gds.beta.influenceMaximization.celf.mutate(graphName :: STRING?, conf│
│                                                              │ that maximize the expected spread of influence in the network."      │iguration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWr│
│                                                              │                                                                      │itten :: INTEGER?, computeMillis :: INTEGER?, totalSpread :: FLOAT?, n│
│                                                              │                                                                      │odeCount :: INTEGER?, configuration :: MAP?)"                         │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.influenceMaximization.celf.mutate.estimate"         │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.influenceMaximization.celf.mutate.estimate(graphNameOrConfig│
│                                                              │                                                                      │uration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRI│
│                                                              │                                                                      │NG?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytes│
│                                                              │                                                                      │Max :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?,│
│                                                              │                                                                      │ heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.influenceMaximization.celf.stats"                   │"Executes the algorithm and returns result statistics without writing │"gds.beta.influenceMaximization.celf.stats(graphName :: STRING?, confi│
│                                                              │the result to Neo4j."                                                 │guration = {} :: MAP?) :: (computeMillis :: INTEGER?, totalSpread :: F│
│                                                              │                                                                      │LOAT?, nodeCount :: INTEGER?, configuration :: MAP?)"                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.influenceMaximization.celf.stats.estimate"          │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.influenceMaximization.celf.stats.estimate(graphNameOrConfigu│
│                                                              │                                                                      │ration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRIN│
│                                                              │                                                                      │G?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesM│
│                                                              │                                                                      │ax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, │
│                                                              │                                                                      │heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.influenceMaximization.celf.stream"                  │"The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes│"gds.beta.influenceMaximization.celf.stream(graphName :: STRING?, conf│
│                                                              │ that maximize the expected spread of influence in the network."      │iguration = {} :: MAP?) :: (nodeId :: INTEGER?, spread :: FLOAT?)"    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.influenceMaximization.celf.stream.estimate"         │"The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes│"gds.beta.influenceMaximization.celf.stream.estimate(graphName :: ANY?│
│                                                              │ that maximize the expected spread of influence in the network."      │, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView │
│                                                              │                                                                      │:: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER│
│                                                              │                                                                      │?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentag│
│                                                              │                                                                      │eMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                         │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.influenceMaximization.celf.write"                   │"The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes│"gds.beta.influenceMaximization.celf.write(graphName :: STRING?, confi│
│                                                              │ that maximize the expected spread of influence in the network."      │guration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWrit│
│                                                              │                                                                      │ten :: INTEGER?, computeMillis :: INTEGER?, totalSpread :: FLOAT?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, configuration :: MAP?)"                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.influenceMaximization.celf.write.estimate"          │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.influenceMaximization.celf.write.estimate(graphNameOrConfigu│
│                                                              │                                                                      │ration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRIN│
│                                                              │                                                                      │G?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesM│
│                                                              │                                                                      │ax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, │
│                                                              │                                                                      │heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.k1coloring.mutate"                                  │"The K-1 Coloring algorithm assigns a color to every node in the graph│"gds.beta.k1coloring.mutate(graphName :: STRING?, configuration = {} :│
│                                                              │."                                                                    │: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?│
│                                                              │                                                                      │, mutateMillis :: INTEGER?, nodeCount :: INTEGER?, colorCount :: INTEG│
│                                                              │                                                                      │ER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, configuration│
│                                                              │                                                                      │ :: MAP?)"                                                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.k1coloring.mutate.estimate"                         │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.k1coloring.mutate.estimate(graphNameOrConfiguration :: ANY?,│
│                                                              │                                                                      │ algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView ::│
│                                                              │                                                                      │ STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?,│
│                                                              │                                                                      │ nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageM│
│                                                              │                                                                      │in :: FLOAT?, heapPercentageMax :: FLOAT?)"                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.k1coloring.stats"                                   │"The K-1 Coloring algorithm assigns a color to every node in the graph│"gds.beta.k1coloring.stats(graphName :: STRING?, configuration = {} ::│
│                                                              │."                                                                    │ MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?,│
│                                                              │                                                                      │ nodeCount :: INTEGER?, colorCount :: INTEGER?, ranIterations :: INTEG│
│                                                              │                                                                      │ER?, didConverge :: BOOLEAN?, configuration :: MAP?)"                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.k1coloring.stats.estimate"                          │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.k1coloring.stats.estimate(graphNameOrConfiguration :: ANY?, │
│                                                              │                                                                      │algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: │
│                                                              │                                                                      │STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, │
│                                                              │                                                                      │nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMi│
│                                                              │                                                                      │n :: FLOAT?, heapPercentageMax :: FLOAT?)"                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.k1coloring.stream"                                  │"The K-1 Coloring algorithm assigns a color to every node in the graph│"gds.beta.k1coloring.stream(graphName :: STRING?, configuration = {} :│
│                                                              │."                                                                    │: MAP?) :: (nodeId :: INTEGER?, color :: INTEGER?)"                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.k1coloring.stream.estimate"                         │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.k1coloring.stream.estimate(graphNameOrConfiguration :: ANY?,│
│                                                              │                                                                      │ algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView ::│
│                                                              │                                                                      │ STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?,│
│                                                              │                                                                      │ nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageM│
│                                                              │                                                                      │in :: FLOAT?, heapPercentageMax :: FLOAT?)"                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.k1coloring.write"                                   │"The K-1 Coloring algorithm assigns a color to every node in the graph│"gds.beta.k1coloring.write(graphName :: STRING?, configuration = {} ::│
│                                                              │."                                                                    │ MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?,│
│                                                              │                                                                      │ writeMillis :: INTEGER?, nodeCount :: INTEGER?, colorCount :: INTEGER│
│                                                              │                                                                      │?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, configuration :│
│                                                              │                                                                      │: MAP?)"                                                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.k1coloring.write.estimate"                          │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.k1coloring.write.estimate(graphNameOrConfiguration :: ANY?, │
│                                                              │                                                                      │algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: │
│                                                              │                                                                      │STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, │
│                                                              │                                                                      │nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMi│
│                                                              │                                                                      │n :: FLOAT?, heapPercentageMax :: FLOAT?)"                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.listProgress"                                       │"List progress events for currently running tasks."                   │"gds.beta.listProgress(jobId =  :: STRING?) :: (jobId :: STRING?, task│
│                                                              │                                                                      │Name :: STRING?, progress :: STRING?, progressBar :: STRING?, status :│
│                                                              │                                                                      │: STRING?, timeStarted :: LOCALTIME?, elapsedTime :: STRING?)"        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.model.drop"                                         │"Drops a loaded model and frees up the resources it occupies."        │"gds.beta.model.drop(modelName :: STRING?, failIfMissing = true :: BOO│
│                                                              │                                                                      │LEAN?) :: (modelInfo :: MAP?, trainConfig :: MAP?, graphSchema :: MAP?│
│                                                              │                                                                      │, loaded :: BOOLEAN?, stored :: BOOLEAN?, creationTime :: DATETIME?, s│
│                                                              │                                                                      │hared :: BOOLEAN?)"                                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.model.exists"                                       │"Checks if a given model exists in the model catalog."                │"gds.beta.model.exists(modelName :: STRING?) :: (modelName :: STRING?,│
│                                                              │                                                                      │ modelType :: STRING?, exists :: BOOLEAN?)"                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.model.list"                                         │"Lists all models contained in the model catalog."                    │"gds.beta.model.list(modelName = __NO_VALUE :: STRING?) :: (modelInfo │
│                                                              │                                                                      │:: MAP?, trainConfig :: MAP?, graphSchema :: MAP?, loaded :: BOOLEAN?,│
│                                                              │                                                                      │ stored :: BOOLEAN?, creationTime :: DATETIME?, shared :: BOOLEAN?)"  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.modularityOptimization.mutate"                      │"The Modularity Optimization algorithm groups the nodes in the graph b│"gds.beta.modularityOptimization.mutate(graphName :: STRING?, configur│
│                                                              │y optimizing the graphs modularity."                                  │ation = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis│
│                                                              │                                                                      │ :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGE│
│                                                              │                                                                      │R?, nodes :: INTEGER?, didConverge :: BOOLEAN?, ranIterations :: INTEG│
│                                                              │                                                                      │ER?, modularity :: FLOAT?, communityCount :: INTEGER?, communityDistri│
│                                                              │                                                                      │bution :: MAP?, configuration :: MAP?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.modularityOptimization.mutate.estimate"             │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.modularityOptimization.mutate.estimate(graphNameOrConfigurat│
│                                                              │                                                                      │ion :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?,│
│                                                              │                                                                      │ treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax │
│                                                              │                                                                      │:: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, hea│
│                                                              │                                                                      │pPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.modularityOptimization.stream"                      │"The Modularity Optimization algorithm groups the nodes in the graph b│"gds.beta.modularityOptimization.stream(graphName :: STRING?, configur│
│                                                              │y optimizing the graphs modularity."                                  │ation = {} :: MAP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?)" │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.modularityOptimization.stream.estimate"             │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.modularityOptimization.stream.estimate(graphNameOrConfigurat│
│                                                              │                                                                      │ion :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?,│
│                                                              │                                                                      │ treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax │
│                                                              │                                                                      │:: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, hea│
│                                                              │                                                                      │pPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.modularityOptimization.write"                       │"The Modularity Optimization algorithm groups the nodes in the graph b│"gds.beta.modularityOptimization.write(graphName :: STRING?, configura│
│                                                              │y optimizing the graphs modularity."                                  │tion = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis │
│                                                              │                                                                      │:: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?│
│                                                              │                                                                      │, nodes :: INTEGER?, didConverge :: BOOLEAN?, ranIterations :: INTEGER│
│                                                              │                                                                      │?, modularity :: FLOAT?, communityCount :: INTEGER?, communityDistribu│
│                                                              │                                                                      │tion :: MAP?, configuration :: MAP?)"                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.modularityOptimization.write.estimate"              │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.modularityOptimization.write.estimate(graphNameOrConfigurati│
│                                                              │                                                                      │on :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, │
│                                                              │                                                                      │treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :│
│                                                              │                                                                      │: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heap│
│                                                              │                                                                      │PercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.node2vec.mutate"                                    │"The Node2Vec algorithm computes embeddings for nodes based on random │"gds.beta.node2vec.mutate(graphName :: STRING?, configuration = {} :: │
│                                                              │walks."                                                               │MAP?) :: (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, lo│
│                                                              │                                                                      │ssPerIteration :: LIST? OF FLOAT?, mutateMillis :: INTEGER?, postProce│
│                                                              │                                                                      │ssingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMilli│
│                                                              │                                                                      │s :: INTEGER?, configuration :: MAP?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.node2vec.mutate.estimate"                           │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.node2vec.mutate.estimate(graphNameOrConfiguration :: ANY?, a│
│                                                              │                                                                      │lgoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: S│
│                                                              │                                                                      │TRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, n│
│                                                              │                                                                      │odeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin│
│                                                              │                                                                      │ :: FLOAT?, heapPercentageMax :: FLOAT?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.node2vec.stream"                                    │"The Node2Vec algorithm computes embeddings for nodes based on random │"gds.beta.node2vec.stream(graphName :: STRING?, configuration = {} :: │
│                                                              │walks."                                                               │MAP?) :: (nodeId :: INTEGER?, embedding :: LIST? OF FLOAT?)"          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.node2vec.stream.estimate"                           │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.node2vec.stream.estimate(graphNameOrConfiguration :: ANY?, a│
│                                                              │                                                                      │lgoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: S│
│                                                              │                                                                      │TRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, n│
│                                                              │                                                                      │odeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin│
│                                                              │                                                                      │ :: FLOAT?, heapPercentageMax :: FLOAT?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.node2vec.write"                                     │"The Node2Vec algorithm computes embeddings for nodes based on random │"gds.beta.node2vec.write(graphName :: STRING?, configuration = {} :: M│
│                                                              │walks."                                                               │AP?) :: (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, pre│
│                                                              │                                                                      │ProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :│
│                                                              │                                                                      │: INTEGER?, configuration :: MAP?, lossPerIteration :: LIST? OF FLOAT?│
│                                                              │                                                                      │)"                                                                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.node2vec.write.estimate"                            │"Returns an estimation of the memory consumption for that procedure." │"gds.beta.node2vec.write.estimate(graphNameOrConfiguration :: ANY?, al│
│                                                              │                                                                      │goConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: ST│
│                                                              │                                                                      │RING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, no│
│                                                              │                                                                      │deCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin │
│                                                              │                                                                      │:: FLOAT?, heapPercentageMax :: FLOAT?)"                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.drop"                                      │"Drops a pipeline and frees up the resources it occupies."            │"gds.beta.pipeline.drop(pipelineName :: STRING?, failIfMissing = true │
│                                                              │                                                                      │:: BOOLEAN?) :: (pipelineInfo :: MAP?, pipelineName :: STRING?, pipeli│
│                                                              │                                                                      │neType :: STRING?, creationTime :: DATETIME?)"                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.exists"                                    │"Checks if a given pipeline exists in the pipeline catalog."          │"gds.beta.pipeline.exists(pipelineName :: STRING?) :: (pipelineName ::│
│                                                              │                                                                      │ STRING?, pipelineType :: STRING?, exists :: BOOLEAN?)"               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.linkPrediction.addFeature"                 │"Add a feature step to an existing link prediction pipeline."         │"gds.beta.pipeline.linkPrediction.addFeature(pipelineName :: STRING?, │
│                                                              │                                                                      │featureType :: STRING?, configuration :: MAP?) :: (name :: STRING?, no│
│                                                              │                                                                      │dePropertySteps :: LIST? OF MAP?, featureSteps :: LIST? OF MAP?, split│
│                                                              │                                                                      │Config :: MAP?, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.linkPrediction.addLogisticRegression"      │"Add a logistic regression configuration to the parameter space of the│"gds.beta.pipeline.linkPrediction.addLogisticRegression(pipelineName :│
│                                                              │ link prediction train pipeline."                                     │: STRING?, config = {} :: MAP?) :: (name :: STRING?, nodePropertySteps│
│                                                              │                                                                      │ :: LIST? OF MAP?, featureSteps :: LIST? OF MAP?, splitConfig :: MAP?,│
│                                                              │                                                                      │ autoTuningConfig :: MAP?, parameterSpace :: ANY?)"                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.linkPrediction.addNodeProperty"            │"Add a node property step to an existing link prediction pipeline."   │"gds.beta.pipeline.linkPrediction.addNodeProperty(pipelineName :: STRI│
│                                                              │                                                                      │NG?, procedureName :: STRING?, procedureConfiguration :: MAP?) :: (nam│
│                                                              │                                                                      │e :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureSteps :: LIST│
│                                                              │                                                                      │? OF MAP?, splitConfig :: MAP?, autoTuningConfig :: MAP?, parameterSpa│
│                                                              │                                                                      │ce :: ANY?)"                                                          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.linkPrediction.configureSplit"             │"Configures the split of the link prediction pipeline."               │"gds.beta.pipeline.linkPrediction.configureSplit(pipelineName :: STRIN│
│                                                              │                                                                      │G?, configuration :: MAP?) :: (name :: STRING?, nodePropertySteps :: L│
│                                                              │                                                                      │IST? OF MAP?, featureSteps :: LIST? OF MAP?, splitConfig :: MAP?, auto│
│                                                              │                                                                      │TuningConfig :: MAP?, parameterSpace :: ANY?)"                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.linkPrediction.create"                     │"Creates a link prediction pipeline in the pipeline catalog."         │"gds.beta.pipeline.linkPrediction.create(pipelineName :: STRING?) :: (│
│                                                              │                                                                      │name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureSteps :: L│
│                                                              │                                                                      │IST? OF MAP?, splitConfig :: MAP?, autoTuningConfig :: MAP?, parameter│
│                                                              │                                                                      │Space :: ANY?)"                                                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.linkPrediction.predict.mutate"             │"Predicts relationships for all non-connected node pairs based on a pr│"gds.beta.pipeline.linkPrediction.predict.mutate(graphName :: STRING?,│
│                                                              │eviously trained LinkPrediction model."                               │ configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, pro│
│                                                              │                                                                      │babilityDistribution :: MAP?, samplingStats :: MAP?, mutateMillis :: I│
│                                                              │                                                                      │NTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTE│
│                                                              │                                                                      │GER?, computeMillis :: INTEGER?, configuration :: MAP?)"              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.linkPrediction.predict.mutate.estimate"    │"Estimates memory for predicting relationships for all non-connected n│"gds.beta.pipeline.linkPrediction.predict.mutate.estimate(graphNameOrC│
│                                                              │ode pairs based on a previously trained LinkPrediction model"         │onfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory ::│
│                                                              │                                                                      │ STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, │
│                                                              │                                                                      │bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTE│
│                                                              │                                                                      │GER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.linkPrediction.predict.stream"             │"Predicts relationships for all non-connected node pairs based on a pr│"gds.beta.pipeline.linkPrediction.predict.stream(graphName :: STRING?,│
│                                                              │eviously trained LinkPrediction model."                               │ configuration = {} :: MAP?) :: (node1 :: INTEGER?, node2 :: INTEGER?,│
│                                                              │                                                                      │ probability :: FLOAT?)"                                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.linkPrediction.predict.stream.estimate"    │"Estimates memory for predicting relationships for all non-connected n│"gds.beta.pipeline.linkPrediction.predict.stream.estimate(graphNameOrC│
│                                                              │ode pairs based on a previously trained LinkPrediction model"         │onfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory ::│
│                                                              │                                                                      │ STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, │
│                                                              │                                                                      │bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTE│
│                                                              │                                                                      │GER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.linkPrediction.train"                      │"Trains a link prediction model based on a pipeline"                  │"gds.beta.pipeline.linkPrediction.train(graphName :: STRING?, configur│
│                                                              │                                                                      │ation = {} :: MAP?) :: (modelSelectionStats :: MAP?, trainMillis :: IN│
│                                                              │                                                                      │TEGER?, modelInfo :: MAP?, configuration :: MAP?)"                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.linkPrediction.train.estimate"             │"Estimates memory for applying a linkPrediction model"                │"gds.beta.pipeline.linkPrediction.train.estimate(graphNameOrConfigurat│
│                                                              │                                                                      │ion :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?,│
│                                                              │                                                                      │ treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax │
│                                                              │                                                                      │:: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, hea│
│                                                              │                                                                      │pPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.list"                                      │"Lists all pipelines contained in the pipeline catalog."              │"gds.beta.pipeline.list(pipelineName = __NO_VALUE :: STRING?) :: (pipe│
│                                                              │                                                                      │lineInfo :: MAP?, pipelineName :: STRING?, pipelineType :: STRING?, cr│
│                                                              │                                                                      │eationTime :: DATETIME?)"                                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.addLogisticRegression"  │"Add a logistic regression configuration to the parameter space of the│"gds.beta.pipeline.nodeClassification.addLogisticRegression(pipelineNa│
│                                                              │ node classification train pipeline."                                 │me :: STRING?, config = {} :: MAP?) :: (name :: STRING?, nodePropertyS│
│                                                              │                                                                      │teps :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitCon│
│                                                              │                                                                      │fig :: MAP?, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.addNodeProperty"        │"Add a node property step to an existing node classification training │"gds.beta.pipeline.nodeClassification.addNodeProperty(pipelineName :: │
│                                                              │pipeline."                                                            │STRING?, procedureName :: STRING?, procedureConfiguration :: MAP?) :: │
│                                                              │                                                                      │(name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featurePropertie│
│                                                              │                                                                      │s :: LIST? OF STRING?, splitConfig :: MAP?, autoTuningConfig :: MAP?, │
│                                                              │                                                                      │parameterSpace :: ANY?)"                                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.configureSplit"         │"Configures the split of the node classification training pipeline."  │"gds.beta.pipeline.nodeClassification.configureSplit(pipelineName :: S│
│                                                              │                                                                      │TRING?, configuration :: MAP?) :: (name :: STRING?, nodePropertySteps │
│                                                              │                                                                      │:: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig :│
│                                                              │                                                                      │: MAP?, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.create"                 │"Creates a node classification training pipeline in the pipeline catal│"gds.beta.pipeline.nodeClassification.create(pipelineName :: STRING?) │
│                                                              │og."                                                                  │:: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureProper│
│                                                              │                                                                      │ties :: LIST? OF STRING?, splitConfig :: MAP?, autoTuningConfig :: MAP│
│                                                              │                                                                      │?, parameterSpace :: ANY?)"                                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.predict.mutate"         │"Predicts classes for all nodes based on a previously trained pipeline│"gds.beta.pipeline.nodeClassification.predict.mutate(graphName :: STRI│
│                                                              │ model"                                                               │NG?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?│
│                                                              │                                                                      │, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProce│
│                                                              │                                                                      │ssingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: M│
│                                                              │                                                                      │AP?)"                                                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.predict.mutate.estimate"│"Estimates memory for predicting classes for all nodes based on a prev│"gds.beta.pipeline.nodeClassification.predict.mutate.estimate(graphNam│
│                                                              │iously trained pipeline model"                                        │eOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemor│
│                                                              │                                                                      │y :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGE│
│                                                              │                                                                      │R?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: │
│                                                              │                                                                      │INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.predict.stream"         │"Predicts classes for all nodes based on a previously trained pipeline│"gds.beta.pipeline.nodeClassification.predict.stream(graphName :: STRI│
│                                                              │ model"                                                               │NG?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, predictedClas│
│                                                              │                                                                      │s :: INTEGER?, predictedProbabilities :: LIST? OF FLOAT?)"            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.predict.stream.estimate"│"Estimates memory for predicting classes for all nodes based on a prev│"gds.beta.pipeline.nodeClassification.predict.stream.estimate(graphNam│
│                                                              │iously trained pipeline model"                                        │eOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemor│
│                                                              │                                                                      │y :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGE│
│                                                              │                                                                      │R?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: │
│                                                              │                                                                      │INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.predict.write"          │"Predicts classes for all nodes based on a previously trained pipeline│"gds.beta.pipeline.nodeClassification.predict.write(graphName :: STRIN│
│                                                              │ model"                                                               │G?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?,│
│                                                              │                                                                      │ writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcess│
│                                                              │                                                                      │ingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP│
│                                                              │                                                                      │?)"                                                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.predict.write.estimate" │"Estimates memory for predicting classes for all nodes based on a prev│"gds.beta.pipeline.nodeClassification.predict.write.estimate(graphName│
│                                                              │iously trained pipeline model"                                        │OrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory│
│                                                              │                                                                      │ :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER│
│                                                              │                                                                      │?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: I│
│                                                              │                                                                      │NTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.selectFeatures"         │"Add one or several features to an existing node classification traini│"gds.beta.pipeline.nodeClassification.selectFeatures(pipelineName :: S│
│                                                              │ng pipeline."                                                         │TRING?, nodeProperties :: ANY?) :: (name :: STRING?, nodePropertySteps│
│                                                              │                                                                      │ :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig │
│                                                              │                                                                      │:: MAP?, autoTuningConfig :: MAP?, parameterSpace :: ANY?)"           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.train"                  │"Trains a node classification model based on a pipeline"              │"gds.beta.pipeline.nodeClassification.train(graphName :: STRING?, conf│
│                                                              │                                                                      │iguration = {} :: MAP?) :: (modelSelectionStats :: MAP?, trainMillis :│
│                                                              │                                                                      │: INTEGER?, modelInfo :: MAP?, configuration :: MAP?)"                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.beta.pipeline.nodeClassification.train.estimate"         │"Estimates memory for training a node classification model based on a │"gds.beta.pipeline.nodeClassification.train.estimate(graphNameOrConfig│
│                                                              │pipeline"                                                             │uration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRI│
│                                                              │                                                                      │NG?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytes│
│                                                              │                                                                      │Max :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?,│
│                                                              │                                                                      │ heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.betweenness.mutate"                                      │"Betweenness centrality measures the relative information flow that pa│"gds.betweenness.mutate(graphName :: STRING?, configuration = {} :: MA│
│                                                              │sses through a node."                                                 │P?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, c│
│                                                              │                                                                      │entralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, prePr│
│                                                              │                                                                      │ocessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :│
│                                                              │                                                                      │: MAP?)"                                                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.betweenness.mutate.estimate"                             │"Betweenness centrality measures the relative information flow that pa│"gds.betweenness.mutate.estimate(graphNameOrConfiguration :: ANY?, alg│
│                                                              │sses through a node."                                                 │oConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STR│
│                                                              │                                                                      │ING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :│
│                                                              │                                                                      │: FLOAT?, heapPercentageMax :: FLOAT?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.betweenness.stats"                                       │"Betweenness centrality measures the relative information flow that pa│"gds.betweenness.stats(graphName :: STRING?, configuration = {} :: MAP│
│                                                              │sses through a node."                                                 │?) :: (centralityDistribution :: MAP?, postProcessingMillis :: INTEGER│
│                                                              │                                                                      │?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configu│
│                                                              │                                                                      │ration :: MAP?)"                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.betweenness.stats.estimate"                              │"Betweenness centrality measures the relative information flow that pa│"gds.betweenness.stats.estimate(graphNameOrConfiguration :: ANY?, algo│
│                                                              │sses through a node."                                                 │Configuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRI│
│                                                              │                                                                      │NG?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin ::│
│                                                              │                                                                      │ FLOAT?, heapPercentageMax :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.betweenness.stream"                                      │"Betweenness centrality measures the relative information flow that pa│"gds.betweenness.stream(graphName :: STRING?, configuration = {} :: MA│
│                                                              │sses through a node."                                                 │P?) :: (nodeId :: INTEGER?, score :: FLOAT?)"                         │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.betweenness.stream.estimate"                             │"Betweenness centrality measures the relative information flow that pa│"gds.betweenness.stream.estimate(graphNameOrConfiguration :: ANY?, alg│
│                                                              │sses through a node."                                                 │oConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STR│
│                                                              │                                                                      │ING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :│
│                                                              │                                                                      │: FLOAT?, heapPercentageMax :: FLOAT?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.betweenness.write"                                       │"Betweenness centrality measures the relative information flow that pa│"gds.betweenness.write(graphName :: STRING?, configuration = {} :: MAP│
│                                                              │sses through a node."                                                 │?) :: (nodePropertiesWritten :: INTEGER?, writeMillis :: INTEGER?, cen│
│                                                              │                                                                      │tralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProc│
│                                                              │                                                                      │essingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: │
│                                                              │                                                                      │MAP?)"                                                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.betweenness.write.estimate"                              │"Betweenness centrality measures the relative information flow that pa│"gds.betweenness.write.estimate(graphNameOrConfiguration :: ANY?, algo│
│                                                              │sses through a node."                                                 │Configuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRI│
│                                                              │                                                                      │NG?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin ::│
│                                                              │                                                                      │ FLOAT?, heapPercentageMax :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.bfs.mutate"                                              │"BFS is a traversal algorithm, which explores all of the neighbor node│"gds.bfs.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (│
│                                                              │s at the present depth prior to moving on to the nodes at the next dep│relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProces│
│                                                              │th level."                                                            │singMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis│
│                                                              │                                                                      │ :: INTEGER?, configuration :: MAP?)"                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.bfs.mutate.estimate"                                     │"Returns an estimation of the memory consumption for that procedure." │"gds.bfs.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfigu│
│                                                              │                                                                      │ration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, ma│
│                                                              │                                                                      │pView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :│
│                                                              │                                                                      │: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?│
│                                                              │                                                                      │, heapPercentageMax :: FLOAT?)"                                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.bfs.stats"                                               │"BFS is a traversal algorithm, which explores all of the neighbor node│"gds.bfs.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (p│
│                                                              │s at the present depth prior to moving on to the nodes at the next dep│ostProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, comp│
│                                                              │th level."                                                            │uteMillis :: INTEGER?, configuration :: MAP?)"                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.bfs.stats.estimate"                                      │"Returns an estimation of the memory consumption for that procedure." │"gds.bfs.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfigur│
│                                                              │                                                                      │ation :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, map│
│                                                              │                                                                      │View :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount ::│
│                                                              │                                                                      │ INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?,│
│                                                              │                                                                      │ heapPercentageMax :: FLOAT?)"                                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.bfs.stream"                                              │"BFS is a traversal algorithm, which explores all of the neighbor node│"gds.bfs.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (│
│                                                              │s at the present depth prior to moving on to the nodes at the next dep│sourceNode :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)" │
│                                                              │th level."                                                            │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.bfs.stream.estimate"                                     │"BFS is a traversal algorithm, which explores all of the neighbor node│"gds.bfs.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?│
│                                                              │s at the present depth prior to moving on to the nodes at the next dep│) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?,│
│                                                              │th level."                                                            │ bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, re│
│                                                              │                                                                      │lationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercenta│
│                                                              │                                                                      │geMax :: FLOAT?)"                                                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.debug.sysInfo"                                           │"Returns details about the status of the system"                      │"gds.debug.sysInfo() :: (key :: STRING?, value :: ANY?)"              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.degree.mutate"                                           │"Degree centrality measures the number of incoming and outgoing relati│"gds.degree.mutate(graphName :: STRING?, configuration = {} :: MAP?) :│
│                                                              │onships from a node."                                                 │: (nodePropertiesWritten :: INTEGER?, centralityDistribution :: MAP?, │
│                                                              │                                                                      │mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcess│
│                                                              │                                                                      │ingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP│
│                                                              │                                                                      │?)"                                                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.degree.mutate.estimate"                                  │"Degree centrality measures the number of incoming and outgoing relati│"gds.degree.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConf│
│                                                              │onships from a node."                                                 │iguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?,│
│                                                              │                                                                      │ mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCoun│
│                                                              │                                                                      │t :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLO│
│                                                              │                                                                      │AT?, heapPercentageMax :: FLOAT?)"                                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.degree.stats"                                            │"Degree centrality measures the number of incoming and outgoing relati│"gds.degree.stats(graphName :: STRING?, configuration = {} :: MAP?) ::│
│                                                              │onships from a node."                                                 │ (centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, pr│
│                                                              │                                                                      │eProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuratio│
│                                                              │                                                                      │n :: MAP?)"                                                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.degree.stats.estimate"                                   │"Degree centrality measures the number of incoming and outgoing relati│"gds.degree.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfi│
│                                                              │onships from a node."                                                 │guration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, │
│                                                              │                                                                      │mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount│
│                                                              │                                                                      │ :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOA│
│                                                              │                                                                      │T?, heapPercentageMax :: FLOAT?)"                                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.degree.stream"                                           │"Degree centrality measures the number of incoming and outgoing relati│"gds.degree.stream(graphName :: STRING?, configuration = {} :: MAP?) :│
│                                                              │onships from a node."                                                 │: (nodeId :: INTEGER?, score :: FLOAT?)"                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.degree.stream.estimate"                                  │"Degree centrality measures the number of incoming and outgoing relati│"gds.degree.stream.estimate(graphNameOrConfiguration :: ANY?, algoConf│
│                                                              │onships from a node."                                                 │iguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?,│
│                                                              │                                                                      │ mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCoun│
│                                                              │                                                                      │t :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLO│
│                                                              │                                                                      │AT?, heapPercentageMax :: FLOAT?)"                                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.degree.write"                                            │"Degree centrality measures the number of incoming and outgoing relati│"gds.degree.write(graphName :: STRING?, configuration = {} :: MAP?) ::│
│                                                              │onships from a node."                                                 │ (nodePropertiesWritten :: INTEGER?, centralityDistribution :: MAP?, w│
│                                                              │                                                                      │riteMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessin│
│                                                              │                                                                      │gMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)│
│                                                              │                                                                      │"                                                                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.degree.write.estimate"                                   │"Degree centrality measures the number of incoming and outgoing relati│"gds.degree.write.estimate(graphNameOrConfiguration :: ANY?, algoConfi│
│                                                              │onships from a node."                                                 │guration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, │
│                                                              │                                                                      │mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount│
│                                                              │                                                                      │ :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOA│
│                                                              │                                                                      │T?, heapPercentageMax :: FLOAT?)"                                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.dfs.mutate"                                              │"Depth-first search (DFS) is an algorithm for traversing or searching │"gds.dfs.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (│
│                                                              │tree or graph data structures. The algorithm starts at the root node (│relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProces│
│                                                              │selecting some arbitrary node as the root node in the case of a graph)│singMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis│
│                                                              │ and explores as far as possible along each branch before backtracking│ :: INTEGER?, configuration :: MAP?)"                                 │
│                                                              │."                                                                    │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.dfs.mutate.estimate"                                     │"Returns an estimation of the memory consumption for that procedure." │"gds.dfs.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfigu│
│                                                              │                                                                      │ration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, ma│
│                                                              │                                                                      │pView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :│
│                                                              │                                                                      │: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?│
│                                                              │                                                                      │, heapPercentageMax :: FLOAT?)"                                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.dfs.stream"                                              │"Depth-first search (DFS) is an algorithm for traversing or searching │"gds.dfs.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (│
│                                                              │tree or graph data structures. The algorithm starts at the root node (│sourceNode :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)" │
│                                                              │selecting some arbitrary node as the root node in the case of a graph)│                                                                      │
│                                                              │ and explores as far as possible along each branch before backtracking│                                                                      │
│                                                              │."                                                                    │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.dfs.stream.estimate"                                     │"Depth-first search (DFS) is an algorithm for traversing or searching │"gds.dfs.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?│
│                                                              │tree or graph data structures. The algorithm starts at the root node (│) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?,│
│                                                              │selecting some arbitrary node as the root node in the case of a graph)│ bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, re│
│                                                              │ and explores as far as possible along each branch before backtracking│lationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercenta│
│                                                              │."                                                                    │geMax :: FLOAT?)"                                                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.eigenvector.mutate"                                      │"Eigenvector Centrality is an algorithm that measures the transitive i│"gds.eigenvector.mutate(graphName :: STRING?, configuration = {} :: MA│
│                                                              │nfluence or connectivity of nodes."                                   │P?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, r│
│                                                              │                                                                      │anIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribut│
│                                                              │                                                                      │ion :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: │
│                                                              │                                                                      │INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.eigenvector.mutate.estimate"                             │"Returns an estimation of the memory consumption for that procedure." │"gds.eigenvector.mutate.estimate(graphNameOrConfiguration :: ANY?, alg│
│                                                              │                                                                      │oConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STR│
│                                                              │                                                                      │ING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :│
│                                                              │                                                                      │: FLOAT?, heapPercentageMax :: FLOAT?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.eigenvector.stats"                                       │"Eigenvector Centrality is an algorithm that measures the transitive i│"gds.eigenvector.stats(graphName :: STRING?, configuration = {} :: MAP│
│                                                              │nfluence or connectivity of nodes."                                   │?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityD│
│                                                              │                                                                      │istribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMi│
│                                                              │                                                                      │llis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.eigenvector.stats.estimate"                              │"Returns an estimation of the memory consumption for that procedure." │"gds.eigenvector.stats.estimate(graphNameOrConfiguration :: ANY?, algo│
│                                                              │                                                                      │Configuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRI│
│                                                              │                                                                      │NG?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin ::│
│                                                              │                                                                      │ FLOAT?, heapPercentageMax :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.eigenvector.stream"                                      │"Eigenvector Centrality is an algorithm that measures the transitive i│"gds.eigenvector.stream(graphName :: STRING?, configuration = {} :: MA│
│                                                              │nfluence or connectivity of nodes."                                   │P?) :: (nodeId :: INTEGER?, score :: FLOAT?)"                         │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.eigenvector.stream.estimate"                             │"Returns an estimation of the memory consumption for that procedure." │"gds.eigenvector.stream.estimate(graphNameOrConfiguration :: ANY?, alg│
│                                                              │                                                                      │oConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STR│
│                                                              │                                                                      │ING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :│
│                                                              │                                                                      │: FLOAT?, heapPercentageMax :: FLOAT?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.eigenvector.write"                                       │"Eigenvector Centrality is an algorithm that measures the transitive i│"gds.eigenvector.write(graphName :: STRING?, configuration = {} :: MAP│
│                                                              │nfluence or connectivity of nodes."                                   │?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ran│
│                                                              │                                                                      │Iterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistributio│
│                                                              │                                                                      │n :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: IN│
│                                                              │                                                                      │TEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.eigenvector.write.estimate"                              │"Returns an estimation of the memory consumption for that procedure." │"gds.eigenvector.write.estimate(graphNameOrConfiguration :: ANY?, algo│
│                                                              │                                                                      │Configuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRI│
│                                                              │                                                                      │NG?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin ::│
│                                                              │                                                                      │ FLOAT?, heapPercentageMax :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.fastRP.mutate"                                           │"Random Projection produces node embeddings via the fastrp algorithm" │"gds.fastRP.mutate(graphName :: STRING?, configuration = {} :: MAP?) :│
│                                                              │                                                                      │: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, nodeCo│
│                                                              │                                                                      │unt :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INT│
│                                                              │                                                                      │EGER?, configuration :: MAP?)"                                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.fastRP.mutate.estimate"                                  │"Random Projection produces node embeddings via the fastrp algorithm" │"gds.fastRP.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConf│
│                                                              │                                                                      │iguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?,│
│                                                              │                                                                      │ mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCoun│
│                                                              │                                                                      │t :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLO│
│                                                              │                                                                      │AT?, heapPercentageMax :: FLOAT?)"                                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.fastRP.stats"                                            │"Random Projection produces node embeddings via the fastrp algorithm" │"gds.fastRP.stats(graphName :: STRING?, configuration = {} :: MAP?) ::│
│                                                              │                                                                      │ (nodeCount :: INTEGER?, preProcessingMillis :: INTEGER?, computeMilli│
│                                                              │                                                                      │s :: INTEGER?, configuration :: MAP?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.fastRP.stats.estimate"                                   │"Random Projection produces node embeddings via the fastrp algorithm" │"gds.fastRP.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfi│
│                                                              │                                                                      │guration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, │
│                                                              │                                                                      │mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount│
│                                                              │                                                                      │ :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOA│
│                                                              │                                                                      │T?, heapPercentageMax :: FLOAT?)"                                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.fastRP.stream"                                           │"Random Projection produces node embeddings via the fastrp algorithm" │"gds.fastRP.stream(graphName :: STRING?, configuration = {} :: MAP?) :│
│                                                              │                                                                      │: (nodeId :: INTEGER?, embedding :: LIST? OF FLOAT?)"                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.fastRP.stream.estimate"                                  │"Random Projection produces node embeddings via the fastrp algorithm" │"gds.fastRP.stream.estimate(graphNameOrConfiguration :: ANY?, algoConf│
│                                                              │                                                                      │iguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?,│
│                                                              │                                                                      │ mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCoun│
│                                                              │                                                                      │t :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLO│
│                                                              │                                                                      │AT?, heapPercentageMax :: FLOAT?)"                                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.fastRP.write"                                            │"Random Projection produces node embeddings via the fastrp algorithm" │"gds.fastRP.write(graphName :: STRING?, configuration = {} :: MAP?) ::│
│                                                              │                                                                      │ (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, preProcess│
│                                                              │                                                                      │ingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEG│
│                                                              │                                                                      │ER?, configuration :: MAP?)"                                          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.fastRP.write.estimate"                                   │"Random Projection produces node embeddings via the fastrp algorithm" │"gds.fastRP.write.estimate(graphNameOrConfiguration :: ANY?, algoConfi│
│                                                              │                                                                      │guration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, │
│                                                              │                                                                      │mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount│
│                                                              │                                                                      │ :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOA│
│                                                              │                                                                      │T?, heapPercentageMax :: FLOAT?)"                                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.deleteRelationships"                               │"Delete the relationship type for a given graph stored in the graph-ca│"gds.graph.deleteRelationships(graphName :: STRING?, relationshipType │
│                                                              │talog."                                                               │:: STRING?) :: (graphName :: STRING?, relationshipType :: STRING?, del│
│                                                              │                                                                      │etedRelationships :: INTEGER?, deletedProperties :: MAP?)"            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.drop"                                              │"Drops a named graph from the catalog and frees up the resources it oc│"gds.graph.drop(graphName :: ANY?, failIfMissing = true :: BOOLEAN?, d│
│                                                              │cupies."                                                              │bName =  :: STRING?, username =  :: STRING?) :: (graphName :: STRING?,│
│                                                              │                                                                      │ database :: STRING?, memoryUsage :: STRING?, sizeInBytes :: INTEGER?,│
│                                                              │                                                                      │ nodeCount :: INTEGER?, relationshipCount :: INTEGER?, configuration :│
│                                                              │                                                                      │: MAP?, density :: FLOAT?, creationTime :: DATETIME?, modificationTime│
│                                                              │                                                                      │ :: DATETIME?, schema :: MAP?)"                                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.exists"                                            │"Checks if a graph exists in the catalog."                            │"gds.graph.exists(graphName :: STRING?) :: (graphName :: STRING?, exis│
│                                                              │                                                                      │ts :: BOOLEAN?)"                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.export"                                            │"Exports a named graph into a new offline Neo4j database."            │"gds.graph.export(graphName :: STRING?, configuration = {} :: MAP?) ::│
│                                                              │                                                                      │ (dbName :: STRING?, graphName :: STRING?, nodeCount :: INTEGER?, rela│
│                                                              │                                                                      │tionshipCount :: INTEGER?, relationshipTypeCount :: INTEGER?, nodeProp│
│                                                              │                                                                      │ertyCount :: INTEGER?, relationshipPropertyCount :: INTEGER?, writeMil│
│                                                              │                                                                      │lis :: INTEGER?)"                                                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.list"                                              │"Lists information about named graphs stored in the catalog."         │"gds.graph.list(graphName = __NO_VALUE :: STRING?) :: (degreeDistribut│
│                                                              │                                                                      │ion :: MAP?, graphName :: STRING?, database :: STRING?, memoryUsage ::│
│                                                              │                                                                      │ STRING?, sizeInBytes :: INTEGER?, nodeCount :: INTEGER?, relationship│
│                                                              │                                                                      │Count :: INTEGER?, configuration :: MAP?, density :: FLOAT?, creationT│
│                                                              │                                                                      │ime :: DATETIME?, modificationTime :: DATETIME?, schema :: MAP?)"     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.nodeProperties.drop"                               │"Removes node properties from a projected graph."                     │"gds.graph.nodeProperties.drop(graphName :: STRING?, nodeProperties ::│
│                                                              │                                                                      │ ANY?, configuration = {} :: MAP?) :: (graphName :: STRING?, nodePrope│
│                                                              │                                                                      │rties :: LIST? OF STRING?, propertiesRemoved :: INTEGER?)"            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.nodeProperties.stream"                             │"Streams the given node properties."                                  │"gds.graph.nodeProperties.stream(graphName :: STRING?, nodeProperties │
│                                                              │                                                                      │:: ANY?, nodeLabels = [*] :: ANY?, configuration = {} :: MAP?) :: (nod│
│                                                              │                                                                      │eId :: INTEGER?, nodeProperty :: STRING?, propertyValue :: ANY?)"     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.nodeProperties.write"                              │"Writes the given node properties to an online Neo4j database."       │"gds.graph.nodeProperties.write(graphName :: STRING?, nodeProperties :│
│                                                              │                                                                      │: ANY?, nodeLabels = [*] :: ANY?, configuration = {} :: MAP?) :: (writ│
│                                                              │                                                                      │eMillis :: INTEGER?, graphName :: STRING?, nodeProperties :: LIST? OF │
│                                                              │                                                                      │STRING?, propertiesWritten :: INTEGER?)"                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.nodeProperty.stream"                               │"Streams the given node property."                                    │"gds.graph.nodeProperty.stream(graphName :: STRING?, nodeProperties ::│
│                                                              │                                                                      │ STRING?, nodeLabels = [*] :: ANY?, configuration = {} :: MAP?) :: (no│
│                                                              │                                                                      │deId :: INTEGER?, propertyValue :: ANY?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.project"                                           │"Creates a named graph in the catalog for use by algorithms."         │"gds.graph.project(graphName :: STRING?, nodeProjection :: ANY?, relat│
│                                                              │                                                                      │ionshipProjection :: ANY?, configuration = {} :: MAP?) :: (nodeProject│
│                                                              │                                                                      │ion :: MAP?, relationshipProjection :: MAP?, graphName :: STRING?, nod│
│                                                              │                                                                      │eCount :: INTEGER?, relationshipCount :: INTEGER?, projectMillis :: IN│
│                                                              │                                                                      │TEGER?)"                                                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.project.cypher"                                    │"Creates a named graph in the catalog for use by algorithms."         │"gds.graph.project.cypher(graphName :: STRING?, nodeQuery :: STRING?, │
│                                                              │                                                                      │relationshipQuery :: STRING?, configuration = {} :: MAP?) :: (nodeQuer│
│                                                              │                                                                      │y :: STRING?, relationshipQuery :: STRING?, graphName :: STRING?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, projectMillis :: INT│
│                                                              │                                                                      │EGER?)"                                                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.project.cypher.estimate"                           │"Returns an estimation of the memory consumption for that procedure." │"gds.graph.project.cypher.estimate(nodeQuery :: STRING?, relationshipQ│
│                                                              │                                                                      │uery :: STRING?, configuration = {} :: MAP?) :: (requiredMemory :: STR│
│                                                              │                                                                      │ING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, byte│
│                                                              │                                                                      │sMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?│
│                                                              │                                                                      │, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.project.estimate"                                  │"Returns an estimation of the memory consumption for that procedure." │"gds.graph.project.estimate(nodeProjection :: ANY?, relationshipProjec│
│                                                              │                                                                      │tion :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING│
│                                                              │                                                                      │?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMa│
│                                                              │                                                                      │x :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, h│
│                                                              │                                                                      │eapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.relationship.write"                                │"Writes the given relationship and an optional relationship property t│"gds.graph.relationship.write(graphName :: STRING?, relationshipType :│
│                                                              │o an online Neo4j database."                                          │: STRING?, relationshipProperty =  :: STRING?, configuration = {} :: M│
│                                                              │                                                                      │AP?) :: (writeMillis :: INTEGER?, graphName :: STRING?, relationshipTy│
│                                                              │                                                                      │pe :: STRING?, relationshipProperty :: STRING?, relationshipsWritten :│
│                                                              │                                                                      │: INTEGER?, propertiesWritten :: INTEGER?)"                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.relationshipProperties.stream"                     │"Streams the given relationship properties."                          │"gds.graph.relationshipProperties.stream(graphName :: STRING?, relatio│
│                                                              │                                                                      │nshipProperties :: LIST? OF STRING?, relationshipTypes = [*] :: LIST? │
│                                                              │                                                                      │OF STRING?, configuration = {} :: MAP?) :: (sourceNodeId :: INTEGER?, │
│                                                              │                                                                      │targetNodeId :: INTEGER?, relationshipType :: STRING?, relationshipPro│
│                                                              │                                                                      │perty :: STRING?, propertyValue :: NUMBER?)"                          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.relationshipProperty.stream"                       │"Streams the given relationship property."                            │"gds.graph.relationshipProperty.stream(graphName :: STRING?, relations│
│                                                              │                                                                      │hipProperty :: STRING?, relationshipTypes = [*] :: LIST? OF STRING?, c│
│                                                              │                                                                      │onfiguration = {} :: MAP?) :: (sourceNodeId :: INTEGER?, targetNodeId │
│                                                              │                                                                      │:: INTEGER?, relationshipType :: STRING?, propertyValue :: NUMBER?)"  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.relationships.drop"                                │"Delete the relationship type for a given graph stored in the graph-ca│"gds.graph.relationships.drop(graphName :: STRING?, relationshipType :│
│                                                              │talog."                                                               │: STRING?) :: (graphName :: STRING?, relationshipType :: STRING?, dele│
│                                                              │                                                                      │tedRelationships :: INTEGER?, deletedProperties :: MAP?)"             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.removeNodeProperties"                              │"Removes node properties from a projected graph."                     │"gds.graph.removeNodeProperties(graphName :: STRING?, nodeProperties :│
│                                                              │                                                                      │: ANY?, configuration = {} :: MAP?) :: (graphName :: STRING?, nodeProp│
│                                                              │                                                                      │erties :: LIST? OF STRING?, propertiesRemoved :: INTEGER?)"           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.streamNodeProperties"                              │"Streams the given node properties."                                  │"gds.graph.streamNodeProperties(graphName :: STRING?, nodeProperties :│
│                                                              │                                                                      │: ANY?, nodeLabels = [*] :: ANY?, configuration = {} :: MAP?) :: (node│
│                                                              │                                                                      │Id :: INTEGER?, nodeProperty :: STRING?, propertyValue :: ANY?)"      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.streamNodeProperty"                                │"Streams the given node property."                                    │"gds.graph.streamNodeProperty(graphName :: STRING?, nodeProperties :: │
│                                                              │                                                                      │STRING?, nodeLabels = [*] :: ANY?, configuration = {} :: MAP?) :: (nod│
│                                                              │                                                                      │eId :: INTEGER?, propertyValue :: ANY?)"                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.streamRelationshipProperties"                      │"Streams the given relationship properties."                          │"gds.graph.streamRelationshipProperties(graphName :: STRING?, relation│
│                                                              │                                                                      │shipProperties :: LIST? OF STRING?, relationshipTypes = [*] :: LIST? O│
│                                                              │                                                                      │F STRING?, configuration = {} :: MAP?) :: (sourceNodeId :: INTEGER?, t│
│                                                              │                                                                      │argetNodeId :: INTEGER?, relationshipType :: STRING?, relationshipProp│
│                                                              │                                                                      │erty :: STRING?, propertyValue :: NUMBER?)"                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.streamRelationshipProperty"                        │"Streams the given relationship property."                            │"gds.graph.streamRelationshipProperty(graphName :: STRING?, relationsh│
│                                                              │                                                                      │ipProperties :: STRING?, relationshipTypes = [*] :: LIST? OF STRING?, │
│                                                              │                                                                      │configuration = {} :: MAP?) :: (sourceNodeId :: INTEGER?, targetNodeId│
│                                                              │                                                                      │ :: INTEGER?, relationshipType :: STRING?, propertyValue :: NUMBER?)" │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.writeNodeProperties"                               │"Writes the given node properties to an online Neo4j database."       │"gds.graph.writeNodeProperties(graphName :: STRING?, nodeProperties ::│
│                                                              │                                                                      │ ANY?, nodeLabels = [*] :: ANY?, configuration = {} :: MAP?) :: (write│
│                                                              │                                                                      │Millis :: INTEGER?, graphName :: STRING?, nodeProperties :: LIST? OF S│
│                                                              │                                                                      │TRING?, propertiesWritten :: INTEGER?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.graph.writeRelationship"                                 │"Writes the given relationship and an optional relationship property t│"gds.graph.writeRelationship(graphName :: STRING?, relationshipType ::│
│                                                              │o an online Neo4j database."                                          │ STRING?, relationshipProperty =  :: STRING?, configuration = {} :: MA│
│                                                              │                                                                      │P?) :: (writeMillis :: INTEGER?, graphName :: STRING?, relationshipTyp│
│                                                              │                                                                      │e :: STRING?, relationshipProperty :: STRING?, relationshipsWritten ::│
│                                                              │                                                                      │ INTEGER?, propertiesWritten :: INTEGER?)"                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.knn.mutate"                                              │"The k-nearest neighbor graph algorithm constructs relationships betwe│"gds.knn.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (│
│                                                              │en nodes if the distance between two nodes is among the k nearest dist│ranIterations :: INTEGER?, nodePairsConsidered :: INTEGER?, didConverg│
│                                                              │ances compared to other nodes.KNN computes distances based on the simi│e :: BOOLEAN?, preProcessingMillis :: INTEGER?, computeMillis :: INTEG│
│                                                              │larity of node properties"                                            │ER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes│
│                                                              │                                                                      │Compared :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDist│
│                                                              │                                                                      │ribution :: MAP?, configuration :: MAP?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.knn.mutate.estimate"                                     │"Returns an estimation of the memory consumption for that procedure." │"gds.knn.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfigu│
│                                                              │                                                                      │ration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, ma│
│                                                              │                                                                      │pView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :│
│                                                              │                                                                      │: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?│
│                                                              │                                                                      │, heapPercentageMax :: FLOAT?)"                                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.knn.stats"                                               │"Executes the algorithm and returns result statistics without writing │"gds.knn.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (r│
│                                                              │the result to Neo4j."                                                 │anIterations :: INTEGER?, didConverge :: BOOLEAN?, nodePairsConsidered│
│                                                              │                                                                      │ :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGE│
│                                                              │                                                                      │R?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, simil│
│                                                              │                                                                      │arityPairs :: INTEGER?, similarityDistribution :: MAP?, configuration │
│                                                              │                                                                      │:: MAP?)"                                                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.knn.stats.estimate"                                      │"Returns an estimation of the memory consumption for that procedure." │"gds.knn.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfigur│
│                                                              │                                                                      │ation :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, map│
│                                                              │                                                                      │View :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount ::│
│                                                              │                                                                      │ INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?,│
│                                                              │                                                                      │ heapPercentageMax :: FLOAT?)"                                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.knn.stream"                                              │"The k-nearest neighbor graph algorithm constructs relationships betwe│"gds.knn.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (│
│                                                              │en nodes if the distance between two nodes is among the k nearest dist│node1 :: INTEGER?, node2 :: INTEGER?, similarity :: FLOAT?)"          │
│                                                              │ances compared to other nodes.KNN computes distances based on the simi│                                                                      │
│                                                              │larity of node properties"                                            │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.knn.stream.estimate"                                     │"Returns an estimation of the memory consumption for that procedure." │"gds.knn.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfigu│
│                                                              │                                                                      │ration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, ma│
│                                                              │                                                                      │pView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :│
│                                                              │                                                                      │: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?│
│                                                              │                                                                      │, heapPercentageMax :: FLOAT?)"                                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.knn.write"                                               │"The k-nearest neighbor graph algorithm constructs relationships betwe│"gds.knn.write(graphName :: STRING?, configuration = {} :: MAP?) :: (r│
│                                                              │en nodes if the distance between two nodes is among the k nearest dist│anIterations :: INTEGER?, didConverge :: BOOLEAN?, nodePairsConsidered│
│                                                              │ances compared to other nodes.KNN computes distances based on the simi│ :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGE│
│                                                              │larity of node properties"                                            │R?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCo│
│                                                              │                                                                      │mpared :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDistri│
│                                                              │                                                                      │bution :: MAP?, configuration :: MAP?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.knn.write.estimate"                                      │"Returns an estimation of the memory consumption for that procedure." │"gds.knn.write.estimate(graphNameOrConfiguration :: ANY?, algoConfigur│
│                                                              │                                                                      │ation :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, map│
│                                                              │                                                                      │View :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount ::│
│                                                              │                                                                      │ INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?,│
│                                                              │                                                                      │ heapPercentageMax :: FLOAT?)"                                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.labelPropagation.mutate"                                 │"The Label Propagation algorithm is a fast algorithm for finding commu│"gds.labelPropagation.mutate(graphName :: STRING?, configuration = {} │
│                                                              │nities in a graph."                                                   │:: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGE│
│                                                              │                                                                      │R?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, communityCount│
│                                                              │                                                                      │ :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: I│
│                                                              │                                                                      │NTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, c│
│                                                              │                                                                      │onfiguration :: MAP?)"                                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.labelPropagation.mutate.estimate"                        │"Returns an estimation of the memory consumption for that procedure." │"gds.labelPropagation.mutate.estimate(graphNameOrConfiguration :: ANY?│
│                                                              │                                                                      │, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :│
│                                                              │                                                                      │: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?│
│                                                              │                                                                      │, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentage│
│                                                              │                                                                      │Min :: FLOAT?, heapPercentageMax :: FLOAT?)"                          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.labelPropagation.stats"                                  │"Executes the algorithm and returns result statistics without writing │"gds.labelPropagation.stats(graphName :: STRING?, configuration = {} :│
│                                                              │the result to Neo4j."                                                 │: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, commun│
│                                                              │                                                                      │ityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMil│
│                                                              │                                                                      │lis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INT│
│                                                              │                                                                      │EGER?, configuration :: MAP?)"                                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.labelPropagation.stats.estimate"                         │"Returns an estimation of the memory consumption for that procedure." │"gds.labelPropagation.stats.estimate(graphNameOrConfiguration :: ANY?,│
│                                                              │                                                                      │ algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView ::│
│                                                              │                                                                      │ STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?,│
│                                                              │                                                                      │ nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageM│
│                                                              │                                                                      │in :: FLOAT?, heapPercentageMax :: FLOAT?)"                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.labelPropagation.stream"                                 │"The Label Propagation algorithm is a fast algorithm for finding commu│"gds.labelPropagation.stream(graphName :: STRING?, configuration = {} │
│                                                              │nities in a graph."                                                   │:: MAP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?)"            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.labelPropagation.stream.estimate"                        │"Returns an estimation of the memory consumption for that procedure." │"gds.labelPropagation.stream.estimate(graphNameOrConfiguration :: ANY?│
│                                                              │                                                                      │, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :│
│                                                              │                                                                      │: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?│
│                                                              │                                                                      │, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentage│
│                                                              │                                                                      │Min :: FLOAT?, heapPercentageMax :: FLOAT?)"                          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.labelPropagation.write"                                  │"The Label Propagation algorithm is a fast algorithm for finding commu│"gds.labelPropagation.write(graphName :: STRING?, configuration = {} :│
│                                                              │nities in a graph."                                                   │: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?│
│                                                              │                                                                      │, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, communityCount :│
│                                                              │                                                                      │: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INT│
│                                                              │                                                                      │EGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, con│
│                                                              │                                                                      │figuration :: MAP?)"                                                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.labelPropagation.write.estimate"                         │"Returns an estimation of the memory consumption for that procedure." │"gds.labelPropagation.write.estimate(graphNameOrConfiguration :: ANY?,│
│                                                              │                                                                      │ algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView ::│
│                                                              │                                                                      │ STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?,│
│                                                              │                                                                      │ nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageM│
│                                                              │                                                                      │in :: FLOAT?, heapPercentageMax :: FLOAT?)"                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.list"                                                    │"CALL gds.list - lists all algorithm procedures, their description and│"gds.list(name =  :: STRING?) :: (name :: STRING?, description :: STRI│
│                                                              │ signature"                                                           │NG?, signature :: STRING?, type :: STRING?)"                          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.localClusteringCoefficient.mutate"                       │"The local clustering coefficient is a metric quantifying how connecte│"gds.localClusteringCoefficient.mutate(graphName :: STRING?, configura│
│                                                              │d the neighborhood of a node is."                                     │tion = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten│
│                                                              │                                                                      │ :: INTEGER?, averageClusteringCoefficient :: FLOAT?, nodeCount :: INT│
│                                                              │                                                                      │EGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGE│
│                                                              │                                                                      │R?, computeMillis :: INTEGER?, configuration :: MAP?)"                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.localClusteringCoefficient.mutate.estimate"              │"Returns an estimation of the memory consumption for that procedure." │"gds.localClusteringCoefficient.mutate.estimate(graphNameOrConfigurati│
│                                                              │                                                                      │on :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, │
│                                                              │                                                                      │treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :│
│                                                              │                                                                      │: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heap│
│                                                              │                                                                      │PercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.localClusteringCoefficient.stats"                        │"Executes the algorithm and returns result statistics without writing │"gds.localClusteringCoefficient.stats(graphName :: STRING?, configurat│
│                                                              │the result to Neo4j."                                                 │ion = {} :: MAP?) :: (averageClusteringCoefficient :: FLOAT?, nodeCoun│
│                                                              │                                                                      │t :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :│
│                                                              │                                                                      │: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.localClusteringCoefficient.stats.estimate"               │"Returns an estimation of the memory consumption for that procedure." │"gds.localClusteringCoefficient.stats.estimate(graphNameOrConfiguratio│
│                                                              │                                                                      │n :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, t│
│                                                              │                                                                      │reeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax ::│
│                                                              │                                                                      │ INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapP│
│                                                              │                                                                      │ercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.localClusteringCoefficient.stream"                       │"The local clustering coefficient is a metric quantifying how connecte│"gds.localClusteringCoefficient.stream(graphName :: STRING?, configura│
│                                                              │d the neighborhood of a node is."                                     │tion = {} :: MAP?) :: (nodeId :: INTEGER?, localClusteringCoefficient │
│                                                              │                                                                      │:: FLOAT?)"                                                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.localClusteringCoefficient.stream.estimate"              │"Returns an estimation of the memory consumption for that procedure." │"gds.localClusteringCoefficient.stream.estimate(graphNameOrConfigurati│
│                                                              │                                                                      │on :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, │
│                                                              │                                                                      │treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :│
│                                                              │                                                                      │: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heap│
│                                                              │                                                                      │PercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.localClusteringCoefficient.write"                        │"The local clustering coefficient is a metric quantifying how connecte│"gds.localClusteringCoefficient.write(graphName :: STRING?, configurat│
│                                                              │d the neighborhood of a node is."                                     │ion = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :│
│                                                              │                                                                      │: INTEGER?, averageClusteringCoefficient :: FLOAT?, nodeCount :: INTEG│
│                                                              │                                                                      │ER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?│
│                                                              │                                                                      │, computeMillis :: INTEGER?, configuration :: MAP?)"                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.localClusteringCoefficient.write.estimate"               │"Returns an estimation of the memory consumption for that procedure." │"gds.localClusteringCoefficient.write.estimate(graphNameOrConfiguratio│
│                                                              │                                                                      │n :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, t│
│                                                              │                                                                      │reeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax ::│
│                                                              │                                                                      │ INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapP│
│                                                              │                                                                      │ercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.louvain.mutate"                                          │"The Louvain method for community detection is an algorithm for detect│"gds.louvain.mutate(graphName :: STRING?, configuration = {} :: MAP?) │
│                                                              │ing communities in networks."                                         │:: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, modul│
│                                                              │                                                                      │arity :: FLOAT?, modularities :: LIST? OF FLOAT?, ranLevels :: INTEGER│
│                                                              │                                                                      │?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProc│
│                                                              │                                                                      │essingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMill│
│                                                              │                                                                      │is :: INTEGER?, configuration :: MAP?)"                               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.louvain.mutate.estimate"                                 │"Returns an estimation of the memory consumption for that procedure." │"gds.louvain.mutate.estimate(graphNameOrConfiguration :: ANY?, algoCon│
│                                                              │                                                                      │figuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?│
│                                                              │                                                                      │, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCou│
│                                                              │                                                                      │nt :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FL│
│                                                              │                                                                      │OAT?, heapPercentageMax :: FLOAT?)"                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.louvain.stats"                                           │"Executes the algorithm and returns result statistics without writing │"gds.louvain.stats(graphName :: STRING?, configuration = {} :: MAP?) :│
│                                                              │the result to Neo4j."                                                 │: (modularity :: FLOAT?, modularities :: LIST? OF FLOAT?, ranLevels ::│
│                                                              │                                                                      │ INTEGER?, communityCount :: INTEGER?, communityDistribution :: MAP?, │
│                                                              │                                                                      │postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, com│
│                                                              │                                                                      │puteMillis :: INTEGER?, configuration :: MAP?)"                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.louvain.stats.estimate"                                  │"Returns an estimation of the memory consumption for that procedure." │"gds.louvain.stats.estimate(graphNameOrConfiguration :: ANY?, algoConf│
│                                                              │                                                                      │iguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?,│
│                                                              │                                                                      │ mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCoun│
│                                                              │                                                                      │t :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLO│
│                                                              │                                                                      │AT?, heapPercentageMax :: FLOAT?)"                                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.louvain.stream"                                          │"The Louvain method for community detection is an algorithm for detect│"gds.louvain.stream(graphName :: STRING?, configuration = {} :: MAP?) │
│                                                              │ing communities in networks."                                         │:: (nodeId :: INTEGER?, communityId :: INTEGER?, intermediateCommunity│
│                                                              │                                                                      │Ids :: LIST? OF INTEGER?)"                                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.louvain.stream.estimate"                                 │"Returns an estimation of the memory consumption for that procedure." │"gds.louvain.stream.estimate(graphNameOrConfiguration :: ANY?, algoCon│
│                                                              │                                                                      │figuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?│
│                                                              │                                                                      │, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCou│
│                                                              │                                                                      │nt :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FL│
│                                                              │                                                                      │OAT?, heapPercentageMax :: FLOAT?)"                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.louvain.write"                                           │"The Louvain method for community detection is an algorithm for detect│"gds.louvain.write(graphName :: STRING?, configuration = {} :: MAP?) :│
│                                                              │ing communities in networks."                                         │: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, modular│
│                                                              │                                                                      │ity :: FLOAT?, modularities :: LIST? OF FLOAT?, ranLevels :: INTEGER?,│
│                                                              │                                                                      │ communityCount :: INTEGER?, communityDistribution :: MAP?, postProces│
│                                                              │                                                                      │singMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis│
│                                                              │                                                                      │ :: INTEGER?, configuration :: MAP?)"                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.louvain.write.estimate"                                  │"Returns an estimation of the memory consumption for that procedure." │"gds.louvain.write.estimate(graphNameOrConfiguration :: ANY?, algoConf│
│                                                              │                                                                      │iguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?,│
│                                                              │                                                                      │ mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCoun│
│                                                              │                                                                      │t :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLO│
│                                                              │                                                                      │AT?, heapPercentageMax :: FLOAT?)"                                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.nodeSimilarity.mutate"                                   │"The Node Similarity algorithm compares a set of nodes based on the no│"gds.nodeSimilarity.mutate(graphName :: STRING?, configuration = {} ::│
│                                                              │des they are connected to. Two nodes are considered similar if they sh│ MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?,│
│                                                              │are many of the same neighbors. Node Similarity computes pair-wise sim│ mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesComp│
│                                                              │ilarities based on the Jaccard metric."                               │ared :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDistribu│
│                                                              │                                                                      │tion :: MAP?, configuration :: MAP?)"                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.nodeSimilarity.mutate.estimate"                          │"Returns an estimation of the memory consumption for that procedure." │"gds.nodeSimilarity.mutate.estimate(graphNameOrConfiguration :: ANY?, │
│                                                              │                                                                      │algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: │
│                                                              │                                                                      │STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, │
│                                                              │                                                                      │nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMi│
│                                                              │                                                                      │n :: FLOAT?, heapPercentageMax :: FLOAT?)"                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.nodeSimilarity.stats"                                    │"Executes the algorithm and returns result statistics without writing │"gds.nodeSimilarity.stats(graphName :: STRING?, configuration = {} :: │
│                                                              │the result to Neo4j."                                                 │MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, │
│                                                              │                                                                      │postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, similarit│
│                                                              │                                                                      │yPairs :: INTEGER?, similarityDistribution :: MAP?, configuration :: M│
│                                                              │                                                                      │AP?)"                                                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.nodeSimilarity.stats.estimate"                           │"Returns an estimation of the memory consumption for that procedure." │"gds.nodeSimilarity.stats.estimate(graphNameOrConfiguration :: ANY?, a│
│                                                              │                                                                      │lgoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: S│
│                                                              │                                                                      │TRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, n│
│                                                              │                                                                      │odeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin│
│                                                              │                                                                      │ :: FLOAT?, heapPercentageMax :: FLOAT?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.nodeSimilarity.stream"                                   │"The Node Similarity algorithm compares a set of nodes based on the no│"gds.nodeSimilarity.stream(graphName :: STRING?, configuration = {} ::│
│                                                              │des they are connected to. Two nodes are considered similar if they sh│ MAP?) :: (node1 :: INTEGER?, node2 :: INTEGER?, similarity :: FLOAT?)│
│                                                              │are many of the same neighbors. Node Similarity computes pair-wise sim│"                                                                     │
│                                                              │ilarities based on the Jaccard metric."                               │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.nodeSimilarity.stream.estimate"                          │"Returns an estimation of the memory consumption for that procedure." │"gds.nodeSimilarity.stream.estimate(graphNameOrConfiguration :: ANY?, │
│                                                              │                                                                      │algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: │
│                                                              │                                                                      │STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, │
│                                                              │                                                                      │nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMi│
│                                                              │                                                                      │n :: FLOAT?, heapPercentageMax :: FLOAT?)"                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.nodeSimilarity.write"                                    │"The Node Similarity algorithm compares a set of nodes based on the no│"gds.nodeSimilarity.write(graphName :: STRING?, configuration = {} :: │
│                                                              │des they are connected to. Two nodes are considered similar if they sh│MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, │
│                                                              │are many of the same neighbors. Node Similarity computes pair-wise sim│writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompar│
│                                                              │ilarities based on the Jaccard metric."                               │ed :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDistributi│
│                                                              │                                                                      │on :: MAP?, configuration :: MAP?)"                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.nodeSimilarity.write.estimate"                           │"Returns an estimation of the memory consumption for that procedure." │"gds.nodeSimilarity.write.estimate(graphNameOrConfiguration :: ANY?, a│
│                                                              │                                                                      │lgoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: S│
│                                                              │                                                                      │TRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, n│
│                                                              │                                                                      │odeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin│
│                                                              │                                                                      │ :: FLOAT?, heapPercentageMax :: FLOAT?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.pageRank.mutate"                                         │"Page Rank is an algorithm that measures the transitive influence or c│"gds.pageRank.mutate(graphName :: STRING?, configuration = {} :: MAP?)│
│                                                              │onnectivity of nodes."                                                │ :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranI│
│                                                              │                                                                      │terations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution│
│                                                              │                                                                      │ :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INT│
│                                                              │                                                                      │EGER?, computeMillis :: INTEGER?, configuration :: MAP?)"             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.pageRank.mutate.estimate"                                │"Returns an estimation of the memory consumption for that procedure." │"gds.pageRank.mutate.estimate(graphNameOrConfiguration :: ANY?, algoCo│
│                                                              │                                                                      │nfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING│
│                                                              │                                                                      │?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCo│
│                                                              │                                                                      │unt :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: F│
│                                                              │                                                                      │LOAT?, heapPercentageMax :: FLOAT?)"                                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.pageRank.stats"                                          │"Executes the algorithm and returns result statistics without writing │"gds.pageRank.stats(graphName :: STRING?, configuration = {} :: MAP?) │
│                                                              │the result to Neo4j."                                                 │:: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDist│
│                                                              │                                                                      │ribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMilli│
│                                                              │                                                                      │s :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.pageRank.stats.estimate"                                 │"Returns an estimation of the memory consumption for that procedure." │"gds.pageRank.stats.estimate(graphNameOrConfiguration :: ANY?, algoCon│
│                                                              │                                                                      │figuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?│
│                                                              │                                                                      │, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCou│
│                                                              │                                                                      │nt :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FL│
│                                                              │                                                                      │OAT?, heapPercentageMax :: FLOAT?)"                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.pageRank.stream"                                         │"Page Rank is an algorithm that measures the transitive influence or c│"gds.pageRank.stream(graphName :: STRING?, configuration = {} :: MAP?)│
│                                                              │onnectivity of nodes."                                                │ :: (nodeId :: INTEGER?, score :: FLOAT?)"                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.pageRank.stream.estimate"                                │"Returns an estimation of the memory consumption for that procedure." │"gds.pageRank.stream.estimate(graphNameOrConfiguration :: ANY?, algoCo│
│                                                              │                                                                      │nfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING│
│                                                              │                                                                      │?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCo│
│                                                              │                                                                      │unt :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: F│
│                                                              │                                                                      │LOAT?, heapPercentageMax :: FLOAT?)"                                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.pageRank.write"                                          │"Page Rank is an algorithm that measures the transitive influence or c│"gds.pageRank.write(graphName :: STRING?, configuration = {} :: MAP?) │
│                                                              │onnectivity of nodes."                                                │:: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIte│
│                                                              │                                                                      │rations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :│
│                                                              │                                                                      │: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEG│
│                                                              │                                                                      │ER?, computeMillis :: INTEGER?, configuration :: MAP?)"               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.pageRank.write.estimate"                                 │"Returns an estimation of the memory consumption for that procedure." │"gds.pageRank.write.estimate(graphNameOrConfiguration :: ANY?, algoCon│
│                                                              │                                                                      │figuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?│
│                                                              │                                                                      │, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCou│
│                                                              │                                                                      │nt :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FL│
│                                                              │                                                                      │OAT?, heapPercentageMax :: FLOAT?)"                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.randomWalk.stats"                                        │"Random Walk is an algorithm that provides random paths in a graph. It│"gds.randomWalk.stats(graphName :: STRING?, configuration = {} :: MAP?│
│                                                              │’s similar to how a drunk person traverses a city."                   │) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, conf│
│                                                              │                                                                      │iguration :: MAP?)"                                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.randomWalk.stats.estimate"                               │"Returns an estimation of the memory consumption for that procedure." │"gds.randomWalk.stats.estimate(graphNameOrConfiguration :: ANY?, algoC│
│                                                              │                                                                      │onfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRIN│
│                                                              │                                                                      │G?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeC│
│                                                              │                                                                      │ount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: │
│                                                              │                                                                      │FLOAT?, heapPercentageMax :: FLOAT?)"                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.randomWalk.stream"                                       │"Random Walk is an algorithm that provides random paths in a graph. It│"gds.randomWalk.stream(graphName :: STRING?, configuration = {} :: MAP│
│                                                              │’s similar to how a drunk person traverses a city."                   │?) :: (nodeIds :: LIST? OF INTEGER?, path :: PATH?)"                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.randomWalk.stream.estimate"                              │"Returns an estimation of the memory consumption for that procedure." │"gds.randomWalk.stream.estimate(graphNameOrConfiguration :: ANY?, algo│
│                                                              │                                                                      │Configuration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRI│
│                                                              │                                                                      │NG?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, node│
│                                                              │                                                                      │Count :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin ::│
│                                                              │                                                                      │ FLOAT?, heapPercentageMax :: FLOAT?)"                                │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.astar.mutate"                               │"The A* shortest path algorithm computes the shortest path between a p│"gds.shortestPath.astar.mutate(graphName :: STRING?, configuration = {│
│                                                              │air of nodes. It uses the relationship weight property to compare path│} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEG│
│                                                              │ lengths. In addition, this implementation uses the haversine distance│ER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?│
│                                                              │ as a heuristic to converge faster."                                  │, computeMillis :: INTEGER?, configuration :: MAP?)"                  │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.astar.mutate.estimate"                      │"Returns an estimation of the memory consumption for that procedure." │"gds.shortestPath.astar.mutate.estimate(graphNameOrConfiguration :: AN│
│                                                              │                                                                      │Y?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView│
│                                                              │                                                                      │ :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGE│
│                                                              │                                                                      │R?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercenta│
│                                                              │                                                                      │geMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.astar.stream"                               │"The A* shortest path algorithm computes the shortest path between a p│"gds.shortestPath.astar.stream(graphName :: STRING?, configuration = {│
│                                                              │air of nodes. It uses the relationship weight property to compare path│} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNode :│
│                                                              │ lengths. In addition, this implementation uses the haversine distance│: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, costs :│
│                                                              │ as a heuristic to converge faster."                                  │: LIST? OF FLOAT?, path :: PATH?)"                                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.astar.stream.estimate"                      │"Returns an estimation of the memory consumption for that procedure." │"gds.shortestPath.astar.stream.estimate(graphNameOrConfiguration :: AN│
│                                                              │                                                                      │Y?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView│
│                                                              │                                                                      │ :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGE│
│                                                              │                                                                      │R?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercenta│
│                                                              │                                                                      │geMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.astar.write"                                │"The A* shortest path algorithm computes the shortest path between a p│"gds.shortestPath.astar.write(graphName :: STRING?, configuration = {}│
│                                                              │air of nodes. It uses the relationship weight property to compare path│ :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTEGER│
│                                                              │ lengths. In addition, this implementation uses the haversine distance│?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, │
│                                                              │ as a heuristic to converge faster."                                  │computeMillis :: INTEGER?, configuration :: MAP?)"                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.astar.write.estimate"                       │"Returns an estimation of the memory consumption for that procedure." │"gds.shortestPath.astar.write.estimate(graphNameOrConfiguration :: ANY│
│                                                              │                                                                      │?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView │
│                                                              │                                                                      │:: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER│
│                                                              │                                                                      │?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentag│
│                                                              │                                                                      │eMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                         │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.dijkstra.mutate"                            │"The Dijkstra shortest path algorithm computes the shortest (weighted)│"gds.shortestPath.dijkstra.mutate(graphName :: STRING?, configuration │
│                                                              │ path between a pair of nodes."                                       │= {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: IN│
│                                                              │                                                                      │TEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEG│
│                                                              │                                                                      │ER?, computeMillis :: INTEGER?, configuration :: MAP?)"               │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.dijkstra.mutate.estimate"                   │"Returns an estimation of the memory consumption for that procedure." │"gds.shortestPath.dijkstra.mutate.estimate(graphNameOrConfiguration ::│
│                                                              │                                                                      │ ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeV│
│                                                              │                                                                      │iew :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INT│
│                                                              │                                                                      │EGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPerce│
│                                                              │                                                                      │ntageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.dijkstra.stream"                            │"The Dijkstra shortest path algorithm computes the shortest (weighted)│"gds.shortestPath.dijkstra.stream(graphName :: STRING?, configuration │
│                                                              │ path between a pair of nodes."                                       │= {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNod│
│                                                              │                                                                      │e :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, cost│
│                                                              │                                                                      │s :: LIST? OF FLOAT?, path :: PATH?)"                                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.dijkstra.stream.estimate"                   │"Returns an estimation of the memory consumption for that procedure." │"gds.shortestPath.dijkstra.stream.estimate(graphNameOrConfiguration ::│
│                                                              │                                                                      │ ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeV│
│                                                              │                                                                      │iew :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INT│
│                                                              │                                                                      │EGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPerce│
│                                                              │                                                                      │ntageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.dijkstra.write"                             │"The Dijkstra shortest path algorithm computes the shortest (weighted)│"gds.shortestPath.dijkstra.write(graphName :: STRING?, configuration =│
│                                                              │ path between a pair of nodes."                                       │ {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTE│
│                                                              │                                                                      │GER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER│
│                                                              │                                                                      │?, computeMillis :: INTEGER?, configuration :: MAP?)"                 │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.dijkstra.write.estimate"                    │"Returns an estimation of the memory consumption for that procedure." │"gds.shortestPath.dijkstra.write.estimate(graphNameOrConfiguration :: │
│                                                              │                                                                      │ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeVi│
│                                                              │                                                                      │ew :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTE│
│                                                              │                                                                      │GER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercen│
│                                                              │                                                                      │tageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.yens.mutate"                                │"The Yen's shortest path algorithm computes the k shortest (weighted) │"gds.shortestPath.yens.mutate(graphName :: STRING?, configuration = {}│
│                                                              │paths between a pair of nodes."                                       │ :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGE│
│                                                              │                                                                      │R?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?,│
│                                                              │                                                                      │ computeMillis :: INTEGER?, configuration :: MAP?)"                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.yens.mutate.estimate"                       │"Returns an estimation of the memory consumption for that procedure." │"gds.shortestPath.yens.mutate.estimate(graphNameOrConfiguration :: ANY│
│                                                              │                                                                      │?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView │
│                                                              │                                                                      │:: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER│
│                                                              │                                                                      │?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentag│
│                                                              │                                                                      │eMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                         │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.yens.stream"                                │"The Yen's shortest path algorithm computes the k shortest (weighted) │"gds.shortestPath.yens.stream(graphName :: STRING?, configuration = {}│
│                                                              │paths between a pair of nodes."                                       │ :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNode ::│
│                                                              │                                                                      │ INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, costs ::│
│                                                              │                                                                      │ LIST? OF FLOAT?, path :: PATH?)"                                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.yens.stream.estimate"                       │"Returns an estimation of the memory consumption for that procedure." │"gds.shortestPath.yens.stream.estimate(graphNameOrConfiguration :: ANY│
│                                                              │                                                                      │?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView │
│                                                              │                                                                      │:: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER│
│                                                              │                                                                      │?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentag│
│                                                              │                                                                      │eMin :: FLOAT?, heapPercentageMax :: FLOAT?)"                         │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.yens.write"                                 │"The Yen's shortest path algorithm computes the k shortest (weighted) │"gds.shortestPath.yens.write(graphName :: STRING?, configuration = {} │
│                                                              │paths between a pair of nodes."                                       │:: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTEGER?│
│                                                              │                                                                      │, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, c│
│                                                              │                                                                      │omputeMillis :: INTEGER?, configuration :: MAP?)"                     │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.shortestPath.yens.write.estimate"                        │"Returns an estimation of the memory consumption for that procedure." │"gds.shortestPath.yens.write.estimate(graphNameOrConfiguration :: ANY?│
│                                                              │                                                                      │, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :│
│                                                              │                                                                      │: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?│
│                                                              │                                                                      │, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentage│
│                                                              │                                                                      │Min :: FLOAT?, heapPercentageMax :: FLOAT?)"                          │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.triangleCount.mutate"                                    │"Triangle counting is a community detection graph algorithm that is us│"gds.triangleCount.mutate(graphName :: STRING?, configuration = {} :: │
│                                                              │ed to determine the number of triangles passing through each node in t│MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?,│
│                                                              │he graph."                                                            │ globalTriangleCount :: INTEGER?, nodeCount :: INTEGER?, postProcessin│
│                                                              │                                                                      │gMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis ::│
│                                                              │                                                                      │ INTEGER?, configuration :: MAP?)"                                    │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.triangleCount.mutate.estimate"                           │"Returns an estimation of the memory consumption for that procedure." │"gds.triangleCount.mutate.estimate(graphNameOrConfiguration :: ANY?, a│
│                                                              │                                                                      │lgoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: S│
│                                                              │                                                                      │TRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, n│
│                                                              │                                                                      │odeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin│
│                                                              │                                                                      │ :: FLOAT?, heapPercentageMax :: FLOAT?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.triangleCount.stats"                                     │"Executes the algorithm and returns result statistics without writing │"gds.triangleCount.stats(graphName :: STRING?, configuration = {} :: M│
│                                                              │the result to Neo4j."                                                 │AP?) :: (globalTriangleCount :: INTEGER?, nodeCount :: INTEGER?, postP│
│                                                              │                                                                      │rocessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeM│
│                                                              │                                                                      │illis :: INTEGER?, configuration :: MAP?)"                            │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.triangleCount.stats.estimate"                            │"Returns an estimation of the memory consumption for that procedure." │"gds.triangleCount.stats.estimate(graphNameOrConfiguration :: ANY?, al│
│                                                              │                                                                      │goConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: ST│
│                                                              │                                                                      │RING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, no│
│                                                              │                                                                      │deCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin │
│                                                              │                                                                      │:: FLOAT?, heapPercentageMax :: FLOAT?)"                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.triangleCount.stream"                                    │"Triangle counting is a community detection graph algorithm that is us│"gds.triangleCount.stream(graphName :: STRING?, configuration = {} :: │
│                                                              │ed to determine the number of triangles passing through each node in t│MAP?) :: (nodeId :: INTEGER?, triangleCount :: INTEGER?)"             │
│                                                              │he graph."                                                            │                                                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.triangleCount.stream.estimate"                           │"Returns an estimation of the memory consumption for that procedure." │"gds.triangleCount.stream.estimate(graphNameOrConfiguration :: ANY?, a│
│                                                              │                                                                      │lgoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: S│
│                                                              │                                                                      │TRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, n│
│                                                              │                                                                      │odeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin│
│                                                              │                                                                      │ :: FLOAT?, heapPercentageMax :: FLOAT?)"                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.triangleCount.write"                                     │"Triangle counting is a community detection graph algorithm that is us│"gds.triangleCount.write(graphName :: STRING?, configuration = {} :: M│
│                                                              │ed to determine the number of triangles passing through each node in t│AP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, g│
│                                                              │he graph."                                                            │lobalTriangleCount :: INTEGER?, nodeCount :: INTEGER?, postProcessingM│
│                                                              │                                                                      │illis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: I│
│                                                              │                                                                      │NTEGER?, configuration :: MAP?)"                                      │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.triangleCount.write.estimate"                            │"Triangle counting is a community detection graph algorithm that is us│"gds.triangleCount.write.estimate(graphNameOrConfiguration :: ANY?, al│
│                                                              │ed to determine the number of triangles passing through each node in t│goConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: ST│
│                                                              │he graph."                                                            │RING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, no│
│                                                              │                                                                      │deCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin │
│                                                              │                                                                      │:: FLOAT?, heapPercentageMax :: FLOAT?)"                              │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.wcc.mutate"                                              │"The WCC algorithm finds sets of connected nodes in an undirected grap│"gds.wcc.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (│
│                                                              │h, where all nodes in the same set form a connected component."       │mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, component│
│                                                              │                                                                      │Count :: INTEGER?, componentDistribution :: MAP?, postProcessingMillis│
│                                                              │                                                                      │ :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGE│
│                                                              │                                                                      │R?, configuration :: MAP?)"                                           │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.wcc.mutate.estimate"                                     │"Returns an estimation of the memory consumption for that procedure." │"gds.wcc.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfigu│
│                                                              │                                                                      │ration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, ma│
│                                                              │                                                                      │pView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :│
│                                                              │                                                                      │: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?│
│                                                              │                                                                      │, heapPercentageMax :: FLOAT?)"                                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.wcc.stats"                                               │"Executes the algorithm and returns result statistics without writing │"gds.wcc.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (c│
│                                                              │the result to Neo4j."                                                 │omponentCount :: INTEGER?, componentDistribution :: MAP?, postProcessi│
│                                                              │                                                                      │ngMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :│
│                                                              │                                                                      │: INTEGER?, configuration :: MAP?)"                                   │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.wcc.stats.estimate"                                      │"Returns an estimation of the memory consumption for that procedure." │"gds.wcc.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfigur│
│                                                              │                                                                      │ation :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, map│
│                                                              │                                                                      │View :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount ::│
│                                                              │                                                                      │ INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?,│
│                                                              │                                                                      │ heapPercentageMax :: FLOAT?)"                                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.wcc.stream"                                              │"The WCC algorithm finds sets of connected nodes in an undirected grap│"gds.wcc.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (│
│                                                              │h, where all nodes in the same set form a connected component."       │nodeId :: INTEGER?, componentId :: INTEGER?)"                         │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.wcc.stream.estimate"                                     │"Returns an estimation of the memory consumption for that procedure." │"gds.wcc.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfigu│
│                                                              │                                                                      │ration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, ma│
│                                                              │                                                                      │pView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :│
│                                                              │                                                                      │: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?│
│                                                              │                                                                      │, heapPercentageMax :: FLOAT?)"                                       │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.wcc.write"                                               │"The WCC algorithm finds sets of connected nodes in an undirected grap│"gds.wcc.write(graphName :: STRING?, configuration = {} :: MAP?) :: (w│
│                                                              │h, where all nodes in the same set form a connected component."       │riteMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, componentCo│
│                                                              │                                                                      │unt :: INTEGER?, componentDistribution :: MAP?, postProcessingMillis :│
│                                                              │                                                                      │: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?│
│                                                              │                                                                      │, configuration :: MAP?)"                                             │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤
│"gds.wcc.write.estimate"                                      │"Returns an estimation of the memory consumption for that procedure." │"gds.wcc.write.estimate(graphNameOrConfiguration :: ANY?, algoConfigur│
│                                                              │                                                                      │ation :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, map│
│                                                              │                                                                      │View :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount ::│
│                                                              │                                                                      │ INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?,│
│                                                              │                                                                      │ heapPercentageMax :: FLOAT?)"                                        │
├──────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────┤